<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="robots" content="noindex,nofollow" />
        <style>
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}

            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
                        .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, "Times New Roman", Times, serif }
            .sf-reset h2 span { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset li a { background:none; color:#868686; text-decoration:none; }
            .sf-reset li a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
        </style>
    </head>
    <body>
                    <div id="sf-resetcontent" class="sf-reset">
                <h1>Whoops, looks like something went wrong.</h1>
                                        <div class="block_exception clear_fix">
                            <h2><span>1/1</span> <abbr title="RuntimeException">RuntimeException</abbr>: Failed to write cache file "/home/gonzalo/trackme/app/cache/dev/classes.php".</h2>
                        </div>
                        <div class="block">
                            <ol class="traces list_exception">
       <li> in /home/gonzalo/trackme/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 239</li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::writeCacheFile('/home/gonzalo/trackme/app/cache/dev/classes.php', '&lt;?php 
namespace Symfony\Component\EventDispatcher
{
interface EventSubscriberInterface
{
public static function getSubscribedEvents();
}
}
namespace Symfony\Bundle\FrameworkBundle\EventListener
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class SessionListener implements EventSubscriberInterface
{
private $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function onKernelRequest(GetResponseEvent $event)
{
if (HttpKernelInterface::MASTER_REQUEST !== $event-&gt;getRequestType()) {
return;
}
$request = $event-&gt;getRequest();
if (!$this-&gt;container-&gt;has(&#039;session&#039;) || $request-&gt;hasSession()) {
return;
}
$request-&gt;setSession($this-&gt;container-&gt;get(&#039;session&#039;));
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 128),
);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
interface SessionStorageInterface
{
public function start();
public function isStarted();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function regenerate($destroy = false, $lifetime = null);
public function save();
public function clear();
public function getBag($name);
public function registerBag(SessionBagInterface $bag);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\NativeProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy;
class NativeSessionStorage implements SessionStorageInterface
{
protected $bags;
protected $started = false;
protected $closed = false;
protected $saveHandler;
protected $metadataBag;
public function __construct(array $options = array(), $handler = null, MetadataBag $metaBag = null)
{
ini_set(&#039;session.cache_limiter&#039;,&#039;&#039;); ini_set(&#039;session.use_cookies&#039;, 1);
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
session_register_shutdown();
} else {
register_shutdown_function(&#039;session_write_close&#039;);
}
$this-&gt;setMetadataBag($metaBag);
$this-&gt;setOptions($options);
$this-&gt;setSaveHandler($handler);
}
public function getSaveHandler()
{
return $this-&gt;saveHandler;
}
public function start()
{
if ($this-&gt;started &amp;&amp; !$this-&gt;closed) {
return true;
}
if (!$this-&gt;started &amp;&amp; !$this-&gt;closed &amp;&amp; $this-&gt;saveHandler-&gt;isActive()
&amp;&amp; $this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;loadSession();
return true;
}
if (ini_get(&#039;session.use_cookies&#039;) &amp;&amp; headers_sent()) {
throw new \RuntimeException(&#039;Failed to start the session because headers have already been sent.&#039;);
}
if (!session_start()) {
throw new \RuntimeException(&#039;Failed to start the session&#039;);
}
$this-&gt;loadSession();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(false);
}
return true;
}
public function getId()
{
if (!$this-&gt;started) {
return&#039;&#039;; }
return $this-&gt;saveHandler-&gt;getId();
}
public function setId($id)
{
$this-&gt;saveHandler-&gt;setId($id);
}
public function getName()
{
return $this-&gt;saveHandler-&gt;getName();
}
public function setName($name)
{
$this-&gt;saveHandler-&gt;setName($name);
}
public function regenerate($destroy = false, $lifetime = null)
{
if (null !== $lifetime) {
ini_set(&#039;session.cookie_lifetime&#039;, $lifetime);
}
if ($destroy) {
$this-&gt;metadataBag-&gt;stampNew();
}
return session_regenerate_id($destroy);
}
public function save()
{
session_write_close();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;getSaveHandler()-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(false);
}
$this-&gt;closed = true;
}
public function clear()
{
foreach ($this-&gt;bags as $bag) {
$bag-&gt;clear();
}
$_SESSION = array();
$this-&gt;loadSession();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;bags[$bag-&gt;getName()] = $bag;
}
public function getBag($name)
{
if (!isset($this-&gt;bags[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;The SessionBagInterface %s is not registered.&#039;, $name));
}
if ($this-&gt;saveHandler-&gt;isActive() &amp;&amp; !$this-&gt;started) {
$this-&gt;loadSession();
} elseif (!$this-&gt;started) {
$this-&gt;start();
}
return $this-&gt;bags[$name];
}
public function setMetadataBag(MetadataBag $metaBag = null)
{
if (null === $metaBag) {
$metaBag = new MetadataBag();
}
$this-&gt;metadataBag = $metaBag;
}
public function getMetadataBag()
{
return $this-&gt;metadataBag;
}
public function isStarted()
{
return $this-&gt;started;
}
public function setOptions(array $options)
{
$validOptions = array_flip(array(&#039;cache_limiter&#039;,&#039;cookie_domain&#039;,&#039;cookie_httponly&#039;,&#039;cookie_lifetime&#039;,&#039;cookie_path&#039;,&#039;cookie_secure&#039;,&#039;entropy_file&#039;,&#039;entropy_length&#039;,&#039;gc_divisor&#039;,&#039;gc_maxlifetime&#039;,&#039;gc_probability&#039;,&#039;hash_bits_per_character&#039;,&#039;hash_function&#039;,&#039;name&#039;,&#039;referer_check&#039;,&#039;serialize_handler&#039;,&#039;use_cookies&#039;,&#039;use_only_cookies&#039;,&#039;use_trans_sid&#039;,&#039;upload_progress.enabled&#039;,&#039;upload_progress.cleanup&#039;,&#039;upload_progress.prefix&#039;,&#039;upload_progress.name&#039;,&#039;upload_progress.freq&#039;,&#039;upload_progress.min-freq&#039;,&#039;url_rewriter.tags&#039;,
));
foreach ($options as $key =&gt; $value) {
if (isset($validOptions[$key])) {
ini_set(&#039;session.&#039;.$key, $value);
}
}
}
public function setSaveHandler($saveHandler = null)
{
if (!$saveHandler instanceof AbstractProxy &amp;&amp; $saveHandler instanceof \SessionHandlerInterface) {
$saveHandler = new SessionHandlerProxy($saveHandler);
} elseif (!$saveHandler instanceof AbstractProxy) {
$saveHandler = new NativeProxy();
}
$this-&gt;saveHandler = $saveHandler;
if ($this-&gt;saveHandler instanceof \SessionHandlerInterface) {
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
session_set_save_handler($this-&gt;saveHandler, false);
} else {
session_set_save_handler(
array($this-&gt;saveHandler,&#039;open&#039;),
array($this-&gt;saveHandler,&#039;close&#039;),
array($this-&gt;saveHandler,&#039;read&#039;),
array($this-&gt;saveHandler,&#039;write&#039;),
array($this-&gt;saveHandler,&#039;destroy&#039;),
array($this-&gt;saveHandler,&#039;gc&#039;)
);
}
}
}
protected function loadSession(array &amp;$session = null)
{
if (null === $session) {
$session = &amp;$_SESSION;
}
$bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));
foreach ($bags as $bag) {
$key = $bag-&gt;getStorageKey();
$session[$key] = isset($session[$key]) ? $session[$key] : array();
$bag-&gt;initialize($session[$key]);
}
$this-&gt;started = true;
$this-&gt;closed = false;
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
class NativeSessionHandler extends \SessionHandler {}
} else {
class NativeSessionHandler {}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
class NativeFileSessionHandler extends NativeSessionHandler
{
public function __construct($savePath = null)
{
if (null === $savePath) {
$savePath = ini_get(&#039;session.save_path&#039;);
}
$baseDir = $savePath;
if ($count = substr_count($savePath,&#039;;&#039;)) {
if ($count &gt; 2) {
throw new \InvalidArgumentException(sprintf(&#039;Invalid argument $savePath \&#039;%s\&#039;&#039;, $savePath));
}
$baseDir = ltrim(strrchr($savePath,&#039;;&#039;),&#039;;&#039;);
}
if ($baseDir &amp;&amp; !is_dir($baseDir)) {
mkdir($baseDir, 0777, true);
}
ini_set(&#039;session.save_path&#039;, $savePath);
ini_set(&#039;session.save_handler&#039;,&#039;files&#039;);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
abstract class AbstractProxy
{
protected $wrapper = false;
protected $active = false;
protected $saveHandlerName;
public function getSaveHandlerName()
{
return $this-&gt;saveHandlerName;
}
public function isSessionHandlerInterface()
{
return ($this instanceof \SessionHandlerInterface);
}
public function isWrapper()
{
return $this-&gt;wrapper;
}
public function isActive()
{
return $this-&gt;active;
}
public function setActive($flag)
{
$this-&gt;active = (bool) $flag;
}
public function getId()
{
return session_id();
}
public function setId($id)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the ID of an active session&#039;);
}
session_id($id);
}
public function getName()
{
return session_name();
}
public function setName($name)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the name of an active session&#039;);
}
session_name($name);
}
}
}
namespace
{
interface SessionHandlerInterface
{
public function open($savePath, $sessionName);
public function close();
public function read($sessionId);
public function write($sessionId, $data);
public function destroy($sessionId);
public function gc($lifetime);
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
class SessionHandlerProxy extends AbstractProxy implements \SessionHandlerInterface
{
protected $handler;
public function __construct(\SessionHandlerInterface $handler)
{
$this-&gt;handler = $handler;
$this-&gt;wrapper = ($handler instanceof \SessionHandler);
$this-&gt;saveHandlerName = $this-&gt;wrapper ? ini_get(&#039;session.save_handler&#039;) :&#039;user&#039;;
}
public function open($savePath, $sessionName)
{
$return = (bool) $this-&gt;handler-&gt;open($savePath, $sessionName);
if (true === $return) {
$this-&gt;active = true;
}
return $return;
}
public function close()
{
$this-&gt;active = false;
return (bool) $this-&gt;handler-&gt;close();
}
public function read($id)
{
return (string) $this-&gt;handler-&gt;read($id);
}
public function write($id, $data)
{
return (bool) $this-&gt;handler-&gt;write($id, $data);
}
public function destroy($id)
{
return (bool) $this-&gt;handler-&gt;destroy($id);
}
public function gc($maxlifetime)
{
return (bool) $this-&gt;handler-&gt;gc($maxlifetime);
}
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
interface SessionInterface
{
public function start();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function invalidate($lifetime = null);
public function migrate($destroy = false, $lifetime = null);
public function save();
public function has($name);
public function get($name, $default = null);
public function set($name, $value);
public function all();
public function replace(array $attributes);
public function remove($name);
public function clear();
public function isStarted();
public function registerBag(SessionBagInterface $bag);
public function getBag($name);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBag;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBag;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface;
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;
class Session implements SessionInterface, \IteratorAggregate, \Countable
{
protected $storage;
private $flashName;
private $attributeName;
public function __construct(SessionStorageInterface $storage = null, AttributeBagInterface $attributes = null, FlashBagInterface $flashes = null)
{
$this-&gt;storage = $storage ?: new NativeSessionStorage();
$attributes = $attributes ?: new AttributeBag();
$this-&gt;attributeName = $attributes-&gt;getName();
$this-&gt;registerBag($attributes);
$flashes = $flashes ?: new FlashBag();
$this-&gt;flashName = $flashes-&gt;getName();
$this-&gt;registerBag($flashes);
}
public function start()
{
return $this-&gt;storage-&gt;start();
}
public function has($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;has($name);
}
public function get($name, $default = null)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;get($name, $default);
}
public function set($name, $value)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;set($name, $value);
}
public function all()
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all();
}
public function replace(array $attributes)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;replace($attributes);
}
public function remove($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;remove($name);
}
public function clear()
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;clear();
}
public function isStarted()
{
return $this-&gt;storage-&gt;isStarted();
}
public function getIterator()
{
return new \ArrayIterator($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function count()
{
return count($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function invalidate($lifetime = null)
{
$this-&gt;storage-&gt;clear();
return $this-&gt;migrate(true, $lifetime);
}
public function migrate($destroy = false, $lifetime = null)
{
return $this-&gt;storage-&gt;regenerate($destroy, $lifetime);
}
public function save()
{
$this-&gt;storage-&gt;save();
}
public function getId()
{
return $this-&gt;storage-&gt;getId();
}
public function setId($id)
{
$this-&gt;storage-&gt;setId($id);
}
public function getName()
{
return $this-&gt;storage-&gt;getName();
}
public function setName($name)
{
$this-&gt;storage-&gt;setName($name);
}
public function getMetadataBag()
{
return $this-&gt;storage-&gt;getMetadataBag();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;storage-&gt;registerBag($bag);
}
public function getBag($name)
{
return $this-&gt;storage-&gt;getBag($name);
}
public function getFlashBag()
{
return $this-&gt;getBag($this-&gt;flashName);
}
public function getFlashes()
{
trigger_error(&#039;getFlashes() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
$all = $this-&gt;getBag($this-&gt;flashName)-&gt;all();
$return = array();
if ($all) {
foreach ($all as $name =&gt; $array) {
if (is_numeric(key($array))) {
$return[$name] = reset($array);
} else {
$return[$name] = $array;
}
}
}
return $return;
}
public function setFlashes($values)
{
trigger_error(&#039;setFlashes() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
foreach ($values as $name =&gt; $value) {
$this-&gt;getBag($this-&gt;flashName)-&gt;set($name, $value);
}
}
public function getFlash($name, $default = null)
{
trigger_error(&#039;getFlash() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
$return = $this-&gt;getBag($this-&gt;flashName)-&gt;get($name);
return empty($return) ? $default : reset($return);
}
public function setFlash($name, $value)
{
trigger_error(&#039;setFlash() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
$this-&gt;getBag($this-&gt;flashName)-&gt;set($name, $value);
}
public function hasFlash($name)
{
trigger_error(&#039;hasFlash() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
return $this-&gt;getBag($this-&gt;flashName)-&gt;has($name);
}
public function removeFlash($name)
{
trigger_error(&#039;removeFlash() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
$this-&gt;getBag($this-&gt;flashName)-&gt;get($name);
}
public function clearFlashes()
{
trigger_error(&#039;clearFlashes() is deprecated since version 2.1 and will be removed in 2.3. Use the FlashBag instead.&#039;, E_USER_DEPRECATED);
return $this-&gt;getBag($this-&gt;flashName)-&gt;clear();
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\Security\Core\SecurityContext;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\HttpFoundation\Request;
class GlobalVariables
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function getSecurity()
{
if ($this-&gt;container-&gt;has(&#039;security.context&#039;)) {
return $this-&gt;container-&gt;get(&#039;security.context&#039;);
}
}
public function getUser()
{
if (!$security = $this-&gt;getSecurity()) {
return;
}
if (!$token = $security-&gt;getToken()) {
return;
}
$user = $token-&gt;getUser();
if (!is_object($user)) {
return;
}
return $user;
}
public function getRequest()
{
if ($this-&gt;container-&gt;has(&#039;request&#039;) &amp;&amp; $request = $this-&gt;container-&gt;get(&#039;request&#039;)) {
return $request;
}
}
public function getSession()
{
if ($request = $this-&gt;getRequest()) {
return $request-&gt;getSession();
}
}
public function getEnvironment()
{
return $this-&gt;container-&gt;getParameter(&#039;kernel.environment&#039;);
}
public function getDebug()
{
return (Boolean) $this-&gt;container-&gt;getParameter(&#039;kernel.debug&#039;);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateReferenceInterface
{
public function all();
public function set($name, $value);
public function get($name);
public function getPath();
public function getLogicalName();
}
}
namespace Symfony\Component\Templating
{
class TemplateReference implements TemplateReferenceInterface
{
protected $parameters;
public function __construct($name = null, $engine = null)
{
$this-&gt;parameters = array(&#039;name&#039;=&gt; $name,&#039;engine&#039;=&gt; $engine,
);
}
public function __toString()
{
return $this-&gt;getLogicalName();
}
public function set($name, $value)
{
if (array_key_exists($name, $this-&gt;parameters)) {
$this-&gt;parameters[$name] = $value;
} else {
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
return $this;
}
public function get($name)
{
if (array_key_exists($name, $this-&gt;parameters)) {
return $this-&gt;parameters[$name];
}
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
public function all()
{
return $this-&gt;parameters;
}
public function getPath()
{
return $this-&gt;parameters[&#039;name&#039;];
}
public function getLogicalName()
{
return $this-&gt;parameters[&#039;name&#039;];
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateReference as BaseTemplateReference;
class TemplateReference extends BaseTemplateReference
{
public function __construct($bundle = null, $controller = null, $name = null, $format = null, $engine = null)
{
$this-&gt;parameters = array(&#039;bundle&#039;=&gt; $bundle,&#039;controller&#039;=&gt; $controller,&#039;name&#039;=&gt; $name,&#039;format&#039;=&gt; $format,&#039;engine&#039;=&gt; $engine,
);
}
public function getPath()
{
$controller = str_replace(&#039;\\&#039;,&#039;/&#039;, $this-&gt;get(&#039;controller&#039;));
$path = (empty($controller) ?&#039;&#039;: $controller.&#039;/&#039;).$this-&gt;get(&#039;name&#039;).&#039;.&#039;.$this-&gt;get(&#039;format&#039;).&#039;.&#039;.$this-&gt;get(&#039;engine&#039;);
return empty($this-&gt;parameters[&#039;bundle&#039;]) ?&#039;views/&#039;.$path :&#039;@&#039;.$this-&gt;get(&#039;bundle&#039;).&#039;/Resources/views/&#039;.$path;
}
public function getLogicalName()
{
return sprintf(&#039;%s:%s:%s.%s.%s&#039;, $this-&gt;parameters[&#039;bundle&#039;], $this-&gt;parameters[&#039;controller&#039;], $this-&gt;parameters[&#039;name&#039;], $this-&gt;parameters[&#039;format&#039;], $this-&gt;parameters[&#039;engine&#039;]);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateNameParserInterface
{
public function parse($name);
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateNameParserInterface;
use Symfony\Component\Templating\TemplateReferenceInterface;
use Symfony\Component\HttpKernel\KernelInterface;
class TemplateNameParser implements TemplateNameParserInterface
{
protected $kernel;
protected $cache;
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
$this-&gt;cache = array();
}
public function parse($name)
{
if ($name instanceof TemplateReferenceInterface) {
return $name;
} elseif (isset($this-&gt;cache[$name])) {
return $this-&gt;cache[$name];
}
$name = str_replace(&#039;:/&#039;,&#039;:&#039;, preg_replace(&#039;#/{2,}#&#039;,&#039;/&#039;, strtr($name,&#039;\\&#039;,&#039;/&#039;)));
if (false !== strpos($name,&#039;..&#039;)) {
throw new \RuntimeException(sprintf(&#039;Template name &quot;%s&quot; contains invalid characters.&#039;, $name));
}
$parts = explode(&#039;:&#039;, $name);
if (3 !== count($parts)) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid (format is &quot;bundle:section:template.format.engine&quot;).&#039;, $name));
}
$elements = explode(&#039;.&#039;, $parts[2]);
if (3 &gt; count($elements)) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid (format is &quot;bundle:section:template.format.engine&quot;).&#039;, $name));
}
$engine = array_pop($elements);
$format = array_pop($elements);
$template = new TemplateReference($parts[0], $parts[1], implode(&#039;.&#039;, $elements), $format, $engine);
if ($template-&gt;get(&#039;bundle&#039;)) {
try {
$this-&gt;kernel-&gt;getBundle($template-&gt;get(&#039;bundle&#039;));
} catch (\Exception $e) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid.&#039;, $name), 0, $e);
}
}
return $this-&gt;cache[$name] = $template;
}
}
}
namespace Symfony\Component\Config
{
interface FileLocatorInterface
{
public function locate($name, $currentPath = null, $first = true);
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating\Loader
{
use Symfony\Component\Config\FileLocatorInterface;
use Symfony\Component\Templating\TemplateReferenceInterface;
class TemplateLocator implements FileLocatorInterface
{
protected $locator;
protected $cache;
public function __construct(FileLocatorInterface $locator, $cacheDir = null)
{
if (null !== $cacheDir &amp;&amp; is_file($cache = $cacheDir.&#039;/templates.php&#039;)) {
$this-&gt;cache = require $cache;
}
$this-&gt;locator = $locator;
}
protected function getCacheKey($template)
{
return $template-&gt;getLogicalName();
}
public function locate($template, $currentPath = null, $first = true)
{
if (!$template instanceof TemplateReferenceInterface) {
throw new \InvalidArgumentException(&quot;The template must be an instance of TemplateReferenceInterface.&quot;);
}
$key = $this-&gt;getCacheKey($template);
if (isset($this-&gt;cache[$key])) {
return $this-&gt;cache[$key];
}
try {
return $this-&gt;cache[$key] = $this-&gt;locator-&gt;locate($template-&gt;getPath(), $currentPath);
} catch (\InvalidArgumentException $e) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find template &quot;%s&quot; : &quot;%s&quot;.&#039;, $template, $e-&gt;getMessage()), 0, $e);
}
}
}
}
namespace Symfony\Component\Routing
{
interface RequestContextAwareInterface
{
public function setContext(RequestContext $context);
public function getContext();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\RequestContextAwareInterface;
interface UrlGeneratorInterface extends RequestContextAwareInterface
{
const ABSOLUTE_URL = true;
const ABSOLUTE_PATH = false;
const RELATIVE_PATH =&#039;relative&#039;;
const NETWORK_PATH =&#039;network&#039;;
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH);
}
}
namespace Symfony\Component\Routing\Generator
{
interface ConfigurableRequirementsInterface
{
public function setStrictRequirements($enabled);
public function isStrictRequirements();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Psr\Log\LoggerInterface;
class UrlGenerator implements UrlGeneratorInterface, ConfigurableRequirementsInterface
{
protected $routes;
protected $context;
protected $strictRequirements = true;
protected $logger;
protected $decodedChars = array(&#039;%2F&#039;=&gt;&#039;/&#039;,&#039;%40&#039;=&gt;&#039;@&#039;,&#039;%3A&#039;=&gt;&#039;:&#039;,&#039;%3B&#039;=&gt;&#039;;&#039;,&#039;%2C&#039;=&gt;&#039;,&#039;,&#039;%3D&#039;=&gt;&#039;=&#039;,&#039;%2B&#039;=&gt;&#039;+&#039;,&#039;%21&#039;=&gt;&#039;!&#039;,&#039;%2A&#039;=&gt;&#039;*&#039;,&#039;%7C&#039;=&gt;&#039;|&#039;,
);
public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
$this-&gt;logger = $logger;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function setStrictRequirements($enabled)
{
$this-&gt;strictRequirements = null === $enabled ? null : (Boolean) $enabled;
}
public function isStrictRequirements()
{
return $this-&gt;strictRequirements;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
if (null === $route = $this-&gt;routes-&gt;get($name)) {
throw new RouteNotFoundException(sprintf(&#039;Unable to generate a URL for the named route &quot;%s&quot; as such route does not exist.&#039;, $name));
}
$compiledRoute = $route-&gt;compile();
return $this-&gt;doGenerate($compiledRoute-&gt;getVariables(), $route-&gt;getDefaults(), $route-&gt;getRequirements(), $compiledRoute-&gt;getTokens(), $parameters, $name, $referenceType, $compiledRoute-&gt;getHostTokens());
}
protected function doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $referenceType, $hostTokens)
{
$variables = array_flip($variables);
$mergedParams = array_replace($defaults, $this-&gt;context-&gt;getParameters(), $parameters);
if ($diff = array_diff_key($variables, $mergedParams)) {
throw new MissingMandatoryParametersException(sprintf(&#039;Some mandatory parameters are missing (&quot;%s&quot;) to generate a URL for route &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, array_keys($diff)), $name));
}
$url =&#039;&#039;;
$optional = true;
foreach ($tokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (!$optional || !array_key_exists($token[3], $defaults) || null !== $mergedParams[$token[3]] &amp;&amp; (string) $mergedParams[$token[3]] !== (string) $defaults[$token[3]]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return null;
}
$url = $token[1].$mergedParams[$token[3]].$url;
$optional = false;
}
} else {
$url = $token[1].$url;
$optional = false;
}
}
if (&#039;&#039;=== $url) {
$url =&#039;/&#039;;
}
$url = strtr(rawurlencode($url), $this-&gt;decodedChars);
$url = strtr($url, array(&#039;/../&#039;=&gt;&#039;/%2E%2E/&#039;,&#039;/./&#039;=&gt;&#039;/%2E/&#039;));
if (&#039;/..&#039;=== substr($url, -3)) {
$url = substr($url, 0, -2) .&#039;%2E%2E&#039;;
} elseif (&#039;/.&#039;=== substr($url, -2)) {
$url = substr($url, 0, -1) .&#039;%2E&#039;;
}
$schemeAuthority =&#039;&#039;;
if ($host = $this-&gt;context-&gt;getHost()) {
$scheme = $this-&gt;context-&gt;getScheme();
if (isset($requirements[&#039;_scheme&#039;]) &amp;&amp; ($req = strtolower($requirements[&#039;_scheme&#039;])) &amp;&amp; $scheme !== $req) {
$referenceType = self::ABSOLUTE_URL;
$scheme = $req;
}
if ($hostTokens) {
$routeHost =&#039;&#039;;
foreach ($hostTokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return null;
}
$routeHost = $token[1].$mergedParams[$token[3]].$routeHost;
} else {
$routeHost = $token[1].$routeHost;
}
}
if ($routeHost !== $host) {
$host = $routeHost;
if (self::ABSOLUTE_URL !== $referenceType) {
$referenceType = self::NETWORK_PATH;
}
}
}
if (self::ABSOLUTE_URL === $referenceType || self::NETWORK_PATH === $referenceType) {
$port =&#039;&#039;;
if (&#039;http&#039;=== $scheme &amp;&amp; 80 != $this-&gt;context-&gt;getHttpPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpPort();
} elseif (&#039;https&#039;=== $scheme &amp;&amp; 443 != $this-&gt;context-&gt;getHttpsPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpsPort();
}
$schemeAuthority = self::NETWORK_PATH === $referenceType ?&#039;//&#039;: &quot;$scheme://&quot;;
$schemeAuthority .= $host.$port;
}
}
if (self::RELATIVE_PATH === $referenceType) {
$url = self::getRelativePath($this-&gt;context-&gt;getPathInfo(), $url);
} else {
$url = $schemeAuthority.$this-&gt;context-&gt;getBaseUrl().$url;
}
$extra = array_diff_key($parameters, $variables, $defaults);
if ($extra &amp;&amp; $query = http_build_query($extra,&#039;&#039;,&#039;&amp;&#039;)) {
$url .=&#039;?&#039;.$query;
}
return $url;
}
public static function getRelativePath($basePath, $targetPath)
{
if ($basePath === $targetPath) {
return&#039;&#039;;
}
$sourceDirs = explode(&#039;/&#039;, isset($basePath[0]) &amp;&amp;&#039;/&#039;=== $basePath[0] ? substr($basePath, 1) : $basePath);
$targetDirs = explode(&#039;/&#039;, isset($targetPath[0]) &amp;&amp;&#039;/&#039;=== $targetPath[0] ? substr($targetPath, 1) : $targetPath);
array_pop($sourceDirs);
$targetFile = array_pop($targetDirs);
foreach ($sourceDirs as $i =&gt; $dir) {
if (isset($targetDirs[$i]) &amp;&amp; $dir === $targetDirs[$i]) {
unset($sourceDirs[$i], $targetDirs[$i]);
} else {
break;
}
}
$targetDirs[] = $targetFile;
$path = str_repeat(&#039;../&#039;, count($sourceDirs)) . implode(&#039;/&#039;, $targetDirs);
return&#039;&#039;=== $path ||&#039;/&#039;=== $path[0]
|| false !== ($colonPos = strpos($path,&#039;:&#039;)) &amp;&amp; ($colonPos &lt; ($slashPos = strpos($path,&#039;/&#039;)) || false === $slashPos)
? &quot;./$path&quot; : $path;
}
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\HttpFoundation\Request;
class RequestContext
{
private $baseUrl;
private $pathInfo;
private $method;
private $host;
private $scheme;
private $httpPort;
private $httpsPort;
private $parameters = array();
public function __construct($baseUrl =&#039;&#039;, $method =&#039;GET&#039;, $host =&#039;localhost&#039;, $scheme =&#039;http&#039;, $httpPort = 80, $httpsPort = 443, $path =&#039;/&#039;)
{
$this-&gt;baseUrl = $baseUrl;
$this-&gt;method = strtoupper($method);
$this-&gt;host = $host;
$this-&gt;scheme = strtolower($scheme);
$this-&gt;httpPort = $httpPort;
$this-&gt;httpsPort = $httpsPort;
$this-&gt;pathInfo = $path;
}
public function fromRequest(Request $request)
{
$this-&gt;setBaseUrl($request-&gt;getBaseUrl());
$this-&gt;setPathInfo($request-&gt;getPathInfo());
$this-&gt;setMethod($request-&gt;getMethod());
$this-&gt;setHost($request-&gt;getHost());
$this-&gt;setScheme($request-&gt;getScheme());
$this-&gt;setHttpPort($request-&gt;isSecure() ? $this-&gt;httpPort : $request-&gt;getPort());
$this-&gt;setHttpsPort($request-&gt;isSecure() ? $request-&gt;getPort() : $this-&gt;httpsPort);
}
public function getBaseUrl()
{
return $this-&gt;baseUrl;
}
public function setBaseUrl($baseUrl)
{
$this-&gt;baseUrl = $baseUrl;
}
public function getPathInfo()
{
return $this-&gt;pathInfo;
}
public function setPathInfo($pathInfo)
{
$this-&gt;pathInfo = $pathInfo;
}
public function getMethod()
{
return $this-&gt;method;
}
public function setMethod($method)
{
$this-&gt;method = strtoupper($method);
}
public function getHost()
{
return $this-&gt;host;
}
public function setHost($host)
{
$this-&gt;host = $host;
}
public function getScheme()
{
return $this-&gt;scheme;
}
public function setScheme($scheme)
{
$this-&gt;scheme = strtolower($scheme);
}
public function getHttpPort()
{
return $this-&gt;httpPort;
}
public function setHttpPort($httpPort)
{
$this-&gt;httpPort = $httpPort;
}
public function getHttpsPort()
{
return $this-&gt;httpsPort;
}
public function setHttpsPort($httpsPort)
{
$this-&gt;httpsPort = $httpsPort;
}
public function getParameters()
{
return $this-&gt;parameters;
}
public function setParameters(array $parameters)
{
$this-&gt;parameters = $parameters;
return $this;
}
public function getParameter($name)
{
return isset($this-&gt;parameters[$name]) ? $this-&gt;parameters[$name] : null;
}
public function hasParameter($name)
{
return array_key_exists($name, $this-&gt;parameters);
}
public function setParameter($name, $parameter)
{
$this-&gt;parameters[$name] = $parameter;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
interface UrlMatcherInterface extends RequestContextAwareInterface
{
public function match($pathinfo);
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
interface RouterInterface extends UrlMatcherInterface, UrlGeneratorInterface
{
public function getRouteCollection();
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\ConfigCache;
use Psr\Log\LoggerInterface;
use Symfony\Component\Routing\Generator\ConfigurableRequirementsInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
class Router implements RouterInterface
{
protected $matcher;
protected $generator;
protected $context;
protected $loader;
protected $collection;
protected $resource;
protected $options = array();
protected $logger;
public function __construct(LoaderInterface $loader, $resource, array $options = array(), RequestContext $context = null, LoggerInterface $logger = null)
{
$this-&gt;loader = $loader;
$this-&gt;resource = $resource;
$this-&gt;logger = $logger;
$this-&gt;context = null === $context ? new RequestContext() : $context;
$this-&gt;setOptions($options);
}
public function setOptions(array $options)
{
$this-&gt;options = array(&#039;cache_dir&#039;=&gt; null,&#039;debug&#039;=&gt; false,&#039;generator_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\Dumper\\PhpGeneratorDumper&#039;,&#039;generator_cache_class&#039;=&gt;&#039;ProjectUrlGenerator&#039;,&#039;matcher_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\Dumper\\PhpMatcherDumper&#039;,&#039;matcher_cache_class&#039;=&gt;&#039;ProjectUrlMatcher&#039;,&#039;resource_type&#039;=&gt; null,&#039;strict_requirements&#039;=&gt; true,
);
$invalid = array();
foreach ($options as $key =&gt; $value) {
if (array_key_exists($key, $this-&gt;options)) {
$this-&gt;options[$key] = $value;
} else {
$invalid[] = $key;
}
}
if ($invalid) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the following options: &quot;%s&quot;.&#039;, implode(&#039;\&#039;, \&#039;&#039;, $invalid)));
}
}
public function setOption($key, $value)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
$this-&gt;options[$key] = $value;
}
public function getOption($key)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
return $this-&gt;options[$key];
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;loader-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
}
return $this-&gt;collection;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
if (null !== $this-&gt;matcher) {
$this-&gt;getMatcher()-&gt;setContext($context);
}
if (null !== $this-&gt;generator) {
$this-&gt;getGenerator()-&gt;setContext($context);
}
}
public function getContext()
{
return $this-&gt;context;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
return $this-&gt;getGenerator()-&gt;generate($name, $parameters, $referenceType);
}
public function match($pathinfo)
{
return $this-&gt;getMatcher()-&gt;match($pathinfo);
}
public function getMatcher()
{
if (null !== $this-&gt;matcher) {
return $this-&gt;matcher;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;matcher_cache_class&#039;]) {
return $this-&gt;matcher = new $this-&gt;options[&#039;matcher_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context);
}
$class = $this-&gt;options[&#039;matcher_cache_class&#039;];
$cache = new ConfigCache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;, $this-&gt;options[&#039;debug&#039;]);
if (!$cache-&gt;isFresh($class)) {
$dumper = new $this-&gt;options[&#039;matcher_dumper_class&#039;]($this-&gt;getRouteCollection());
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $this-&gt;options[&#039;matcher_base_class&#039;],
);
$cache-&gt;write($dumper-&gt;dump($options), $this-&gt;getRouteCollection()-&gt;getResources());
}
require_once $cache;
return $this-&gt;matcher = new $class($this-&gt;context);
}
public function getGenerator()
{
if (null !== $this-&gt;generator) {
return $this-&gt;generator;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;generator_cache_class&#039;]) {
$this-&gt;generator = new $this-&gt;options[&#039;generator_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context, $this-&gt;logger);
} else {
$class = $this-&gt;options[&#039;generator_cache_class&#039;];
$cache = new ConfigCache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;, $this-&gt;options[&#039;debug&#039;]);
if (!$cache-&gt;isFresh($class)) {
$dumper = new $this-&gt;options[&#039;generator_dumper_class&#039;]($this-&gt;getRouteCollection());
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $this-&gt;options[&#039;generator_base_class&#039;],
);
$cache-&gt;write($dumper-&gt;dump($options), $this-&gt;getRouteCollection()-&gt;getResources());
}
require_once $cache;
$this-&gt;generator = new $class($this-&gt;context, $this-&gt;logger);
}
if ($this-&gt;generator instanceof ConfigurableRequirementsInterface) {
$this-&gt;generator-&gt;setStrictRequirements($this-&gt;options[&#039;strict_requirements&#039;]);
}
return $this-&gt;generator;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
interface RedirectableUrlMatcherInterface
{
public function redirect($path, $route, $scheme = null);
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Route;
class UrlMatcher implements UrlMatcherInterface
{
const REQUIREMENT_MATCH = 0;
const REQUIREMENT_MISMATCH = 1;
const ROUTE_MATCH = 2;
protected $context;
protected $allow = array();
protected $routes;
public function __construct(RouteCollection $routes, RequestContext $context)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function match($pathinfo)
{
$this-&gt;allow = array();
if ($ret = $this-&gt;matchCollection(rawurldecode($pathinfo), $this-&gt;routes)) {
return $ret;
}
throw 0 &lt; count($this-&gt;allow)
? new MethodNotAllowedException(array_unique(array_map(&#039;strtoupper&#039;, $this-&gt;allow)))
: new ResourceNotFoundException();
}
protected function matchCollection($pathinfo, RouteCollection $routes)
{
foreach ($routes as $name =&gt; $route) {
$compiledRoute = $route-&gt;compile();
if (&#039;&#039;!== $compiledRoute-&gt;getStaticPrefix() &amp;&amp; 0 !== strpos($pathinfo, $compiledRoute-&gt;getStaticPrefix())) {
continue;
}
if (!preg_match($compiledRoute-&gt;getRegex(), $pathinfo, $matches)) {
continue;
}
$hostMatches = array();
if ($compiledRoute-&gt;getHostRegex() &amp;&amp; !preg_match($compiledRoute-&gt;getHostRegex(), $this-&gt;context-&gt;getHost(), $hostMatches)) {
continue;
}
if ($req = $route-&gt;getRequirement(&#039;_method&#039;)) {
if (&#039;HEAD&#039;=== $method = $this-&gt;context-&gt;getMethod()) {
$method =&#039;GET&#039;;
}
if (!in_array($method, $req = explode(&#039;|&#039;, strtoupper($req)))) {
$this-&gt;allow = array_merge($this-&gt;allow, $req);
continue;
}
}
$status = $this-&gt;handleRouteRequirements($pathinfo, $name, $route);
if (self::ROUTE_MATCH === $status[0]) {
return $status[1];
}
if (self::REQUIREMENT_MISMATCH === $status[0]) {
continue;
}
return $this-&gt;getAttributes($route, $name, array_replace($matches, $hostMatches));
}
}
protected function getAttributes(Route $route, $name, array $attributes)
{
$attributes[&#039;_route&#039;] = $name;
return $this-&gt;mergeDefaults($attributes, $route-&gt;getDefaults());
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
$scheme = $route-&gt;getRequirement(&#039;_scheme&#039;);
$status = $scheme &amp;&amp; $scheme !== $this-&gt;context-&gt;getScheme() ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH;
return array($status, null);
}
protected function mergeDefaults($params, $defaults)
{
foreach ($params as $key =&gt; $value) {
if (!is_int($key)) {
$defaults[$key] = $value;
}
}
return $defaults;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Route;
abstract class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface
{
public function match($pathinfo)
{
try {
$parameters = parent::match($pathinfo);
} catch (ResourceNotFoundException $e) {
if (&#039;/&#039;=== substr($pathinfo, -1) || !in_array($this-&gt;context-&gt;getMethod(), array(&#039;HEAD&#039;,&#039;GET&#039;))) {
throw $e;
}
try {
parent::match($pathinfo.&#039;/&#039;);
return $this-&gt;redirect($pathinfo.&#039;/&#039;, null);
} catch (ResourceNotFoundException $e2) {
throw $e;
}
}
return $parameters;
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
$scheme = $route-&gt;getRequirement(&#039;_scheme&#039;);
if ($scheme &amp;&amp; $this-&gt;context-&gt;getScheme() !== $scheme) {
return array(self::ROUTE_MATCH, $this-&gt;redirect($pathinfo, $name, $scheme));
}
return array(self::REQUIREMENT_MATCH, null);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Matcher\RedirectableUrlMatcher as BaseMatcher;
class RedirectableUrlMatcher extends BaseMatcher
{
public function redirect($path, $route, $scheme = null)
{
return array(&#039;_controller&#039;=&gt;&#039;Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController::urlRedirectAction&#039;,&#039;path&#039;=&gt; $path,&#039;permanent&#039;=&gt; true,&#039;scheme&#039;=&gt; $scheme,&#039;httpPort&#039;=&gt; $this-&gt;context-&gt;getHttpPort(),&#039;httpsPort&#039;=&gt; $this-&gt;context-&gt;getHttpsPort(),&#039;_route&#039;=&gt; $route,
);
}
}
}
namespace Symfony\Component\HttpKernel\CacheWarmer
{
interface WarmableInterface
{
public function warmUp($cacheDir);
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Router as BaseRouter;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\HttpKernel\CacheWarmer\WarmableInterface;
use Symfony\Component\DependencyInjection\Exception\ParameterNotFoundException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
class Router extends BaseRouter implements WarmableInterface
{
private $container;
public function __construct(ContainerInterface $container, $resource, array $options = array(), RequestContext $context = null)
{
$this-&gt;container = $container;
$this-&gt;resource = $resource;
$this-&gt;context = null === $context ? new RequestContext() : $context;
$this-&gt;setOptions($options);
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;container-&gt;get(&#039;routing.loader&#039;)-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
$this-&gt;resolveParameters($this-&gt;collection);
}
return $this-&gt;collection;
}
public function warmUp($cacheDir)
{
$currentDir = $this-&gt;getOption(&#039;cache_dir&#039;);
$this-&gt;setOption(&#039;cache_dir&#039;, $cacheDir);
$this-&gt;getMatcher();
$this-&gt;getGenerator();
$this-&gt;setOption(&#039;cache_dir&#039;, $currentDir);
}
private function resolveParameters(RouteCollection $collection)
{
foreach ($collection as $route) {
foreach ($route-&gt;getDefaults() as $name =&gt; $value) {
$route-&gt;setDefault($name, $this-&gt;resolve($value));
}
foreach ($route-&gt;getRequirements() as $name =&gt; $value) {
$route-&gt;setRequirement($name, $this-&gt;resolve($value));
}
$route-&gt;setPath($this-&gt;resolve($route-&gt;getPath()));
$route-&gt;setHost($this-&gt;resolve($route-&gt;getHost()));
}
}
private function resolve($value)
{
if (is_array($value)) {
foreach ($value as $key =&gt; $val) {
$value[$key] = $this-&gt;resolve($val);
}
return $value;
}
if (!is_string($value)) {
return $value;
}
$container = $this-&gt;container;
$escapedValue = preg_replace_callback(&#039;/%%|%([^%\s]+)%/&#039;, function ($match) use ($container, $value) {
if (!isset($match[1])) {
return&#039;%%&#039;;
}
$key = strtolower($match[1]);
if (!$container-&gt;hasParameter($key)) {
throw new ParameterNotFoundException($key);
}
$resolved = $container-&gt;getParameter($key);
if (is_string($resolved) || is_numeric($resolved)) {
return (string) $resolved;
}
throw new RuntimeException(sprintf(&#039;A string value must be composed of strings and/or numbers,&#039;.&#039;but found parameter &quot;%s&quot; of type %s inside string value &quot;%s&quot;.&#039;,
$key,
gettype($resolved),
$value)
);
}, $value);
return str_replace(&#039;%%&#039;,&#039;%&#039;, $escapedValue);
}
}
}
namespace Symfony\Component\HttpFoundation
{
class ParameterBag implements \IteratorAggregate, \Countable
{
protected $parameters;
public function __construct(array $parameters = array())
{
$this-&gt;parameters = $parameters;
}
public function all()
{
return $this-&gt;parameters;
}
public function keys()
{
return array_keys($this-&gt;parameters);
}
public function replace(array $parameters = array())
{
$this-&gt;parameters = $parameters;
}
public function add(array $parameters = array())
{
$this-&gt;parameters = array_replace($this-&gt;parameters, $parameters);
}
public function get($path, $default = null, $deep = false)
{
if (!$deep || false === $pos = strpos($path,&#039;[&#039;)) {
return array_key_exists($path, $this-&gt;parameters) ? $this-&gt;parameters[$path] : $default;
}
$root = substr($path, 0, $pos);
if (!array_key_exists($root, $this-&gt;parameters)) {
return $default;
}
$value = $this-&gt;parameters[$root];
$currentKey = null;
for ($i = $pos, $c = strlen($path); $i &lt; $c; $i++) {
$char = $path[$i];
if (&#039;[&#039;=== $char) {
if (null !== $currentKey) {
throw new \InvalidArgumentException(sprintf(&#039;Malformed path. Unexpected &quot;[&quot; at position %d.&#039;, $i));
}
$currentKey =&#039;&#039;;
} elseif (&#039;]&#039;=== $char) {
if (null === $currentKey) {
throw new \InvalidArgumentException(sprintf(&#039;Malformed path. Unexpected &quot;]&quot; at position %d.&#039;, $i));
}
if (!is_array($value) || !array_key_exists($currentKey, $value)) {
return $default;
}
$value = $value[$currentKey];
$currentKey = null;
} else {
if (null === $currentKey) {
throw new \InvalidArgumentException(sprintf(&#039;Malformed path. Unexpected &quot;%s&quot; at position %d.&#039;, $char, $i));
}
$currentKey .= $char;
}
}
if (null !== $currentKey) {
throw new \InvalidArgumentException(sprintf(&#039;Malformed path. Path must end with &quot;]&quot;.&#039;));
}
return $value;
}
public function set($key, $value)
{
$this-&gt;parameters[$key] = $value;
}
public function has($key)
{
return array_key_exists($key, $this-&gt;parameters);
}
public function remove($key)
{
unset($this-&gt;parameters[$key]);
}
public function getAlpha($key, $default =&#039;&#039;, $deep = false)
{
return preg_replace(&#039;/[^[:alpha:]]/&#039;,&#039;&#039;, $this-&gt;get($key, $default, $deep));
}
public function getAlnum($key, $default =&#039;&#039;, $deep = false)
{
return preg_replace(&#039;/[^[:alnum:]]/&#039;,&#039;&#039;, $this-&gt;get($key, $default, $deep));
}
public function getDigits($key, $default =&#039;&#039;, $deep = false)
{
return str_replace(array(&#039;-&#039;,&#039;+&#039;),&#039;&#039;, $this-&gt;filter($key, $default, $deep, FILTER_SANITIZE_NUMBER_INT));
}
public function getInt($key, $default = 0, $deep = false)
{
return (int) $this-&gt;get($key, $default, $deep);
}
public function filter($key, $default = null, $deep = false, $filter=FILTER_DEFAULT, $options=array())
{
$value = $this-&gt;get($key, $default, $deep);
if (!is_array($options) &amp;&amp; $options) {
$options = array(&#039;flags&#039;=&gt; $options);
}
if (is_array($value) &amp;&amp; !isset($options[&#039;flags&#039;])) {
$options[&#039;flags&#039;] = FILTER_REQUIRE_ARRAY;
}
return filter_var($value, $filter, $options);
}
public function getIterator()
{
return new \ArrayIterator($this-&gt;parameters);
}
public function count()
{
return count($this-&gt;parameters);
}
}
}
namespace Symfony\Component\HttpFoundation
{
class HeaderBag implements \IteratorAggregate, \Countable
{
protected $headers;
protected $cacheControl;
public function __construct(array $headers = array())
{
$this-&gt;cacheControl = array();
$this-&gt;headers = array();
foreach ($headers as $key =&gt; $values) {
$this-&gt;set($key, $values);
}
}
public function __toString()
{
if (!$this-&gt;headers) {
return&#039;&#039;;
}
$max = max(array_map(&#039;strlen&#039;, array_keys($this-&gt;headers))) + 1;
$content =&#039;&#039;;
ksort($this-&gt;headers);
foreach ($this-&gt;headers as $name =&gt; $values) {
$name = implode(&#039;-&#039;, array_map(&#039;ucfirst&#039;, explode(&#039;-&#039;, $name)));
foreach ($values as $value) {
$content .= sprintf(&quot;%-{$max}s %s\r\n&quot;, $name.&#039;:&#039;, $value);
}
}
return $content;
}
public function all()
{
return $this-&gt;headers;
}
public function keys()
{
return array_keys($this-&gt;headers);
}
public function replace(array $headers = array())
{
$this-&gt;headers = array();
$this-&gt;add($headers);
}
public function add(array $headers)
{
foreach ($headers as $key =&gt; $values) {
$this-&gt;set($key, $values);
}
}
public function get($key, $default = null, $first = true)
{
$key = strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;);
if (!array_key_exists($key, $this-&gt;headers)) {
if (null === $default) {
return $first ? null : array();
}
return $first ? $default : array($default);
}
if ($first) {
return count($this-&gt;headers[$key]) ? $this-&gt;headers[$key][0] : $default;
}
return $this-&gt;headers[$key];
}
public function set($key, $values, $replace = true)
{
$key = strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;);
$values = array_values((array) $values);
if (true === $replace || !isset($this-&gt;headers[$key])) {
$this-&gt;headers[$key] = $values;
} else {
$this-&gt;headers[$key] = array_merge($this-&gt;headers[$key], $values);
}
if (&#039;cache-control&#039;=== $key) {
$this-&gt;cacheControl = $this-&gt;parseCacheControl($values[0]);
}
}
public function has($key)
{
return array_key_exists(strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;), $this-&gt;headers);
}
public function contains($key, $value)
{
return in_array($value, $this-&gt;get($key, null, false));
}
public function remove($key)
{
$key = strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;);
unset($this-&gt;headers[$key]);
if (&#039;cache-control&#039;=== $key) {
$this-&gt;cacheControl = array();
}
}
public function getDate($key, \DateTime $default = null)
{
if (null === $value = $this-&gt;get($key)) {
return $default;
}
if (false === $date = \DateTime::createFromFormat(DATE_RFC2822, $value)) {
throw new \RuntimeException(sprintf(&#039;The %s HTTP header is not parseable (%s).&#039;, $key, $value));
}
return $date;
}
public function addCacheControlDirective($key, $value = true)
{
$this-&gt;cacheControl[$key] = $value;
$this-&gt;set(&#039;Cache-Control&#039;, $this-&gt;getCacheControlHeader());
}
public function hasCacheControlDirective($key)
{
return array_key_exists($key, $this-&gt;cacheControl);
}
public function getCacheControlDirective($key)
{
return array_key_exists($key, $this-&gt;cacheControl) ? $this-&gt;cacheControl[$key] : null;
}
public function removeCacheControlDirective($key)
{
unset($this-&gt;cacheControl[$key]);
$this-&gt;set(&#039;Cache-Control&#039;, $this-&gt;getCacheControlHeader());
}
public function getIterator()
{
return new \ArrayIterator($this-&gt;headers);
}
public function count()
{
return count($this-&gt;headers);
}
protected function getCacheControlHeader()
{
$parts = array();
ksort($this-&gt;cacheControl);
foreach ($this-&gt;cacheControl as $key =&gt; $value) {
if (true === $value) {
$parts[] = $key;
} else {
if (preg_match(&#039;#[^a-zA-Z0-9._-]#&#039;, $value)) {
$value =&#039;&quot;&#039;.$value.&#039;&quot;&#039;;
}
$parts[] = &quot;$key=$value&quot;;
}
}
return implode(&#039;, &#039;, $parts);
}
protected function parseCacheControl($header)
{
$cacheControl = array();
preg_match_all(&#039;#([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:&quot;([^&quot;]*)&quot;|([^ \t&quot;,;]*)))?#&#039;, $header, $matches, PREG_SET_ORDER);
foreach ($matches as $match) {
$cacheControl[strtolower($match[1])] = isset($match[3]) ? $match[3] : (isset($match[2]) ? $match[2] : true);
}
return $cacheControl;
}
}
}
namespace Symfony\Component\HttpFoundation
{
use Symfony\Component\HttpFoundation\File\UploadedFile;
class FileBag extends ParameterBag
{
private static $fileKeys = array(&#039;error&#039;,&#039;name&#039;,&#039;size&#039;,&#039;tmp_name&#039;,&#039;type&#039;);
public function __construct(array $parameters = array())
{
$this-&gt;replace($parameters);
}
public function replace(array $files = array())
{
$this-&gt;parameters = array();
$this-&gt;add($files);
}
public function set($key, $value)
{
if (!is_array($value) &amp;&amp; !$value instanceof UploadedFile) {
throw new \InvalidArgumentException(&#039;An uploaded file must be an array or an instance of UploadedFile.&#039;);
}
parent::set($key, $this-&gt;convertFileInformation($value));
}
public function add(array $files = array())
{
foreach ($files as $key =&gt; $file) {
$this-&gt;set($key, $file);
}
}
protected function convertFileInformation($file)
{
if ($file instanceof UploadedFile) {
return $file;
}
$file = $this-&gt;fixPhpFilesArray($file);
if (is_array($file)) {
$keys = array_keys($file);
sort($keys);
if ($keys == self::$fileKeys) {
if (UPLOAD_ERR_NO_FILE == $file[&#039;error&#039;]) {
$file = null;
} else {
$file = new UploadedFile($file[&#039;tmp_name&#039;], $file[&#039;name&#039;], $file[&#039;type&#039;], $file[&#039;size&#039;], $file[&#039;error&#039;]);
}
} else {
$file = array_map(array($this,&#039;convertFileInformation&#039;), $file);
}
}
return $file;
}
protected function fixPhpFilesArray($data)
{
if (!is_array($data)) {
return $data;
}
$keys = array_keys($data);
sort($keys);
if (self::$fileKeys != $keys || !isset($data[&#039;name&#039;]) || !is_array($data[&#039;name&#039;])) {
return $data;
}
$files = $data;
foreach (self::$fileKeys as $k) {
unset($files[$k]);
}
foreach (array_keys($data[&#039;name&#039;]) as $key) {
$files[$key] = $this-&gt;fixPhpFilesArray(array(&#039;error&#039;=&gt; $data[&#039;error&#039;][$key],&#039;name&#039;=&gt; $data[&#039;name&#039;][$key],&#039;type&#039;=&gt; $data[&#039;type&#039;][$key],&#039;tmp_name&#039;=&gt; $data[&#039;tmp_name&#039;][$key],&#039;size&#039;=&gt; $data[&#039;size&#039;][$key]
));
}
return $files;
}
}
}
namespace Symfony\Component\HttpFoundation
{
class ServerBag extends ParameterBag
{
public function getHeaders()
{
$headers = array();
foreach ($this-&gt;parameters as $key =&gt; $value) {
if (0 === strpos($key,&#039;HTTP_&#039;)) {
$headers[substr($key, 5)] = $value;
}
elseif (in_array($key, array(&#039;CONTENT_LENGTH&#039;,&#039;CONTENT_MD5&#039;,&#039;CONTENT_TYPE&#039;))) {
$headers[$key] = $value;
}
}
if (isset($this-&gt;parameters[&#039;PHP_AUTH_USER&#039;])) {
$headers[&#039;PHP_AUTH_USER&#039;] = $this-&gt;parameters[&#039;PHP_AUTH_USER&#039;];
$headers[&#039;PHP_AUTH_PW&#039;] = isset($this-&gt;parameters[&#039;PHP_AUTH_PW&#039;]) ? $this-&gt;parameters[&#039;PHP_AUTH_PW&#039;] :&#039;&#039;;
} else {
$authorizationHeader = null;
if (isset($this-&gt;parameters[&#039;HTTP_AUTHORIZATION&#039;])) {
$authorizationHeader = $this-&gt;parameters[&#039;HTTP_AUTHORIZATION&#039;];
} elseif (isset($this-&gt;parameters[&#039;REDIRECT_HTTP_AUTHORIZATION&#039;])) {
$authorizationHeader = $this-&gt;parameters[&#039;REDIRECT_HTTP_AUTHORIZATION&#039;];
}
if ((null !== $authorizationHeader) &amp;&amp; (0 === stripos($authorizationHeader,&#039;basic&#039;))) {
$exploded = explode(&#039;:&#039;, base64_decode(substr($authorizationHeader, 6)));
if (count($exploded) == 2) {
list($headers[&#039;PHP_AUTH_USER&#039;], $headers[&#039;PHP_AUTH_PW&#039;]) = $exploded;
}
}
}
if (isset($headers[&#039;PHP_AUTH_USER&#039;])) {
$headers[&#039;AUTHORIZATION&#039;] =&#039;Basic &#039;.base64_encode($headers[&#039;PHP_AUTH_USER&#039;].&#039;:&#039;.$headers[&#039;PHP_AUTH_PW&#039;]);
}
return $headers;
}
}
}
namespace Symfony\Component\HttpFoundation
{
use Symfony\Component\HttpFoundation\Session\SessionInterface;
class Request
{
const HEADER_CLIENT_IP =&#039;client_ip&#039;;
const HEADER_CLIENT_HOST =&#039;client_host&#039;;
const HEADER_CLIENT_PROTO =&#039;client_proto&#039;;
const HEADER_CLIENT_PORT =&#039;client_port&#039;;
protected static $trustProxy = false;
protected static $trustedProxies = array();
protected static $trustedHeaders = array(
self::HEADER_CLIENT_IP =&gt;&#039;X_FORWARDED_FOR&#039;,
self::HEADER_CLIENT_HOST =&gt;&#039;X_FORWARDED_HOST&#039;,
self::HEADER_CLIENT_PROTO =&gt;&#039;X_FORWARDED_PROTO&#039;,
self::HEADER_CLIENT_PORT =&gt;&#039;X_FORWARDED_PORT&#039;,
);
protected static $httpMethodParameterOverride = false;
public $attributes;
public $request;
public $query;
public $server;
public $files;
public $cookies;
public $headers;
protected $content;
protected $languages;
protected $charsets;
protected $acceptableContentTypes;
protected $pathInfo;
protected $requestUri;
protected $baseUrl;
protected $basePath;
protected $method;
protected $format;
protected $session;
protected $locale;
protected $defaultLocale =&#039;en&#039;;
protected static $formats;
public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)
{
$this-&gt;initialize($query, $request, $attributes, $cookies, $files, $server, $content);
}
public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)
{
$this-&gt;request = new ParameterBag($request);
$this-&gt;query = new ParameterBag($query);
$this-&gt;attributes = new ParameterBag($attributes);
$this-&gt;cookies = new ParameterBag($cookies);
$this-&gt;files = new FileBag($files);
$this-&gt;server = new ServerBag($server);
$this-&gt;headers = new HeaderBag($this-&gt;server-&gt;getHeaders());
$this-&gt;content = $content;
$this-&gt;languages = null;
$this-&gt;charsets = null;
$this-&gt;acceptableContentTypes = null;
$this-&gt;pathInfo = null;
$this-&gt;requestUri = null;
$this-&gt;baseUrl = null;
$this-&gt;basePath = null;
$this-&gt;method = null;
$this-&gt;format = null;
}
public static function createFromGlobals()
{
$request = new static($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);
if (0 === strpos($request-&gt;headers-&gt;get(&#039;CONTENT_TYPE&#039;),&#039;application/x-www-form-urlencoded&#039;)
&amp;&amp; in_array(strtoupper($request-&gt;server-&gt;get(&#039;REQUEST_METHOD&#039;,&#039;GET&#039;)), array(&#039;PUT&#039;,&#039;DELETE&#039;,&#039;PATCH&#039;))
) {
parse_str($request-&gt;getContent(), $data);
$request-&gt;request = new ParameterBag($data);
}
return $request;
}
public static function create($uri, $method =&#039;GET&#039;, $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
{
$server = array_replace(array(&#039;SERVER_NAME&#039;=&gt;&#039;localhost&#039;,&#039;SERVER_PORT&#039;=&gt; 80,&#039;HTTP_HOST&#039;=&gt;&#039;localhost&#039;,&#039;HTTP_USER_AGENT&#039;=&gt;&#039;Symfony/2.X&#039;,&#039;HTTP_ACCEPT&#039;=&gt;&#039;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#039;,&#039;HTTP_ACCEPT_LANGUAGE&#039;=&gt;&#039;en-us,en;q=0.5&#039;,&#039;HTTP_ACCEPT_CHARSET&#039;=&gt;&#039;ISO-8859-1,utf-8;q=0.7,*;q=0.7&#039;,&#039;REMOTE_ADDR&#039;=&gt;&#039;127.0.0.1&#039;,&#039;SCRIPT_NAME&#039;=&gt;&#039;&#039;,&#039;SCRIPT_FILENAME&#039;=&gt;&#039;&#039;,&#039;SERVER_PROTOCOL&#039;=&gt;&#039;HTTP/1.1&#039;,&#039;REQUEST_TIME&#039;=&gt; time(),
), $server);
$server[&#039;PATH_INFO&#039;] =&#039;&#039;;
$server[&#039;REQUEST_METHOD&#039;] = strtoupper($method);
$components = parse_url($uri);
if (isset($components[&#039;host&#039;])) {
$server[&#039;SERVER_NAME&#039;] = $components[&#039;host&#039;];
$server[&#039;HTTP_HOST&#039;] = $components[&#039;host&#039;];
}
if (isset($components[&#039;scheme&#039;])) {
if (&#039;https&#039;=== $components[&#039;scheme&#039;]) {
$server[&#039;HTTPS&#039;] =&#039;on&#039;;
$server[&#039;SERVER_PORT&#039;] = 443;
} else {
unset($server[&#039;HTTPS&#039;]);
$server[&#039;SERVER_PORT&#039;] = 80;
}
}
if (isset($components[&#039;port&#039;])) {
$server[&#039;SERVER_PORT&#039;] = $components[&#039;port&#039;];
$server[&#039;HTTP_HOST&#039;] = $server[&#039;HTTP_HOST&#039;].&#039;:&#039;.$components[&#039;port&#039;];
}
if (isset($components[&#039;user&#039;])) {
$server[&#039;PHP_AUTH_USER&#039;] = $components[&#039;user&#039;];
}
if (isset($components[&#039;pass&#039;])) {
$server[&#039;PHP_AUTH_PW&#039;] = $components[&#039;pass&#039;];
}
if (!isset($components[&#039;path&#039;])) {
$components[&#039;path&#039;] =&#039;/&#039;;
}
switch (strtoupper($method)) {
case&#039;POST&#039;:
case&#039;PUT&#039;:
case&#039;DELETE&#039;:
if (!isset($server[&#039;CONTENT_TYPE&#039;])) {
$server[&#039;CONTENT_TYPE&#039;] =&#039;application/x-www-form-urlencoded&#039;;
}
case&#039;PATCH&#039;:
$request = $parameters;
$query = array();
break;
default:
$request = array();
$query = $parameters;
break;
}
if (isset($components[&#039;query&#039;])) {
parse_str(html_entity_decode($components[&#039;query&#039;]), $qs);
$query = array_replace($qs, $query);
}
$queryString = http_build_query($query,&#039;&#039;,&#039;&amp;&#039;);
$server[&#039;REQUEST_URI&#039;] = $components[&#039;path&#039;].(&#039;&#039;!== $queryString ?&#039;?&#039;.$queryString :&#039;&#039;);
$server[&#039;QUERY_STRING&#039;] = $queryString;
return new static($query, $request, array(), $cookies, $files, $server, $content);
}
public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)
{
$dup = clone $this;
if ($query !== null) {
$dup-&gt;query = new ParameterBag($query);
}
if ($request !== null) {
$dup-&gt;request = new ParameterBag($request);
}
if ($attributes !== null) {
$dup-&gt;attributes = new ParameterBag($attributes);
}
if ($cookies !== null) {
$dup-&gt;cookies = new ParameterBag($cookies);
}
if ($files !== null) {
$dup-&gt;files = new FileBag($files);
}
if ($server !== null) {
$dup-&gt;server = new ServerBag($server);
$dup-&gt;headers = new HeaderBag($dup-&gt;server-&gt;getHeaders());
}
$dup-&gt;languages = null;
$dup-&gt;charsets = null;
$dup-&gt;acceptableContentTypes = null;
$dup-&gt;pathInfo = null;
$dup-&gt;requestUri = null;
$dup-&gt;baseUrl = null;
$dup-&gt;basePath = null;
$dup-&gt;method = null;
$dup-&gt;format = null;
return $dup;
}
public function __clone()
{
$this-&gt;query = clone $this-&gt;query;
$this-&gt;request = clone $this-&gt;request;
$this-&gt;attributes = clone $this-&gt;attributes;
$this-&gt;cookies = clone $this-&gt;cookies;
$this-&gt;files = clone $this-&gt;files;
$this-&gt;server = clone $this-&gt;server;
$this-&gt;headers = clone $this-&gt;headers;
}
public function __toString()
{
return
sprintf(&#039;%s %s %s&#039;, $this-&gt;getMethod(), $this-&gt;getRequestUri(), $this-&gt;server-&gt;get(&#039;SERVER_PROTOCOL&#039;)).&quot;\r\n&quot;.
$this-&gt;headers.&quot;\r\n&quot;.
$this-&gt;getContent();
}
public function overrideGlobals()
{
$_GET = $this-&gt;query-&gt;all();
$_POST = $this-&gt;request-&gt;all();
$_SERVER = $this-&gt;server-&gt;all();
$_COOKIE = $this-&gt;cookies-&gt;all();
foreach ($this-&gt;headers-&gt;all() as $key =&gt; $value) {
$key = strtoupper(str_replace(&#039;-&#039;,&#039;_&#039;, $key));
if (in_array($key, array(&#039;CONTENT_TYPE&#039;,&#039;CONTENT_LENGTH&#039;))) {
$_SERVER[$key] = implode(&#039;, &#039;, $value);
} else {
$_SERVER[&#039;HTTP_&#039;.$key] = implode(&#039;, &#039;, $value);
}
}
$request = array(&#039;g&#039;=&gt; $_GET,&#039;p&#039;=&gt; $_POST,&#039;c&#039;=&gt; $_COOKIE);
$requestOrder = ini_get(&#039;request_order&#039;) ?: ini_get(&#039;variable_order&#039;);
$requestOrder = preg_replace(&#039;#[^cgp]#&#039;,&#039;&#039;, strtolower($requestOrder)) ?:&#039;gp&#039;;
$_REQUEST = array();
foreach (str_split($requestOrder) as $order) {
$_REQUEST = array_merge($_REQUEST, $request[$order]);
}
}
public static function trustProxyData()
{
trigger_error(&#039;trustProxyData() is deprecated since version 2.0 and will be removed in 2.3. Use setTrustedProxies() instead.&#039;, E_USER_DEPRECATED);
self::$trustProxy = true;
}
public static function setTrustedProxies(array $proxies)
{
self::$trustedProxies = $proxies;
self::$trustProxy = $proxies ? true : false;
}
public static function getTrustedProxies()
{
return self::$trustedProxies;
}
public static function setTrustedHeaderName($key, $value)
{
if (!array_key_exists($key, self::$trustedHeaders)) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to set the trusted header name for key &quot;%s&quot;.&#039;, $key));
}
self::$trustedHeaders[$key] = $value;
}
public static function isProxyTrusted()
{
return self::$trustProxy;
}
public static function normalizeQueryString($qs)
{
if (&#039;&#039;== $qs) {
return&#039;&#039;;
}
$parts = array();
$order = array();
foreach (explode(&#039;&amp;&#039;, $qs) as $param) {
if (&#039;&#039;=== $param ||&#039;=&#039;=== $param[0]) {
continue;
}
$keyValuePair = explode(&#039;=&#039;, $param, 2);
$parts[] = isset($keyValuePair[1]) ?
rawurlencode(urldecode($keyValuePair[0])).&#039;=&#039;.rawurlencode(urldecode($keyValuePair[1])) :
rawurlencode(urldecode($keyValuePair[0]));
$order[] = urldecode($keyValuePair[0]);
}
array_multisort($order, SORT_ASC, $parts);
return implode(&#039;&amp;&#039;, $parts);
}
public static function enableHttpMethodParameterOverride()
{
self::$httpMethodParameterOverride = true;
}
public static function getHttpMethodParameterOverride()
{
return self::$httpMethodParameterOverride;
}
public function get($key, $default = null, $deep = false)
{
return $this-&gt;query-&gt;get($key, $this-&gt;attributes-&gt;get($key, $this-&gt;request-&gt;get($key, $default, $deep), $deep), $deep);
}
public function getSession()
{
return $this-&gt;session;
}
public function hasPreviousSession()
{
return $this-&gt;hasSession() &amp;&amp; $this-&gt;cookies-&gt;has($this-&gt;session-&gt;getName());
}
public function hasSession()
{
return null !== $this-&gt;session;
}
public function setSession(SessionInterface $session)
{
$this-&gt;session = $session;
}
public function getClientIp()
{
$ip = $this-&gt;server-&gt;get(&#039;REMOTE_ADDR&#039;);
if (!self::$trustProxy) {
return $ip;
}
if (!self::$trustedHeaders[self::HEADER_CLIENT_IP] || !$this-&gt;headers-&gt;has(self::$trustedHeaders[self::HEADER_CLIENT_IP])) {
return $ip;
}
$clientIps = array_map(&#039;trim&#039;, explode(&#039;,&#039;, $this-&gt;headers-&gt;get(self::$trustedHeaders[self::HEADER_CLIENT_IP])));
$clientIps[] = $ip;
$trustedProxies = self::$trustProxy &amp;&amp; !self::$trustedProxies ? array($ip) : self::$trustedProxies;
$ip = $clientIps[0];
$clientIps = array_diff($clientIps, $trustedProxies);
return $clientIps ? array_pop($clientIps) : $ip;
}
public function getScriptName()
{
return $this-&gt;server-&gt;get(&#039;SCRIPT_NAME&#039;, $this-&gt;server-&gt;get(&#039;ORIG_SCRIPT_NAME&#039;,&#039;&#039;));
}
public function getPathInfo()
{
if (null === $this-&gt;pathInfo) {
$this-&gt;pathInfo = $this-&gt;preparePathInfo();
}
return $this-&gt;pathInfo;
}
public function getBasePath()
{
if (null === $this-&gt;basePath) {
$this-&gt;basePath = $this-&gt;prepareBasePath();
}
return $this-&gt;basePath;
}
public function getBaseUrl()
{
if (null === $this-&gt;baseUrl) {
$this-&gt;baseUrl = $this-&gt;prepareBaseUrl();
}
return $this-&gt;baseUrl;
}
public function getScheme()
{
return $this-&gt;isSecure() ?&#039;https&#039;:&#039;http&#039;;
}
public function getPort()
{
if (self::$trustProxy) {
if (self::$trustedHeaders[self::HEADER_CLIENT_PORT] &amp;&amp; $port = $this-&gt;headers-&gt;get(self::$trustedHeaders[self::HEADER_CLIENT_PORT])) {
return $port;
}
if (self::$trustedHeaders[self::HEADER_CLIENT_PROTO] &amp;&amp;&#039;https&#039;=== $this-&gt;headers-&gt;get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO],&#039;http&#039;)) {
return 443;
}
}
return $this-&gt;server-&gt;get(&#039;SERVER_PORT&#039;);
}
public function getUser()
{
return $this-&gt;server-&gt;get(&#039;PHP_AUTH_USER&#039;);
}
public function getPassword()
{
return $this-&gt;server-&gt;get(&#039;PHP_AUTH_PW&#039;);
}
public function getUserInfo()
{
$userinfo = $this-&gt;getUser();
$pass = $this-&gt;getPassword();
if (&#039;&#039;!= $pass) {
$userinfo .= &quot;:$pass&quot;;
}
return $userinfo;
}
public function getHttpHost()
{
$scheme = $this-&gt;getScheme();
$port = $this-&gt;getPort();
if ((&#039;http&#039;== $scheme &amp;&amp; $port == 80) || (&#039;https&#039;== $scheme &amp;&amp; $port == 443)) {
return $this-&gt;getHost();
}
return $this-&gt;getHost().&#039;:&#039;.$port;
}
public function getRequestUri()
{
if (null === $this-&gt;requestUri) {
$this-&gt;requestUri = $this-&gt;prepareRequestUri();
}
return $this-&gt;requestUri;
}
public function getSchemeAndHttpHost()
{
return $this-&gt;getScheme().&#039;://&#039;.$this-&gt;getHttpHost();
}
public function getUri()
{
if (null !== $qs = $this-&gt;getQueryString()) {
$qs =&#039;?&#039;.$qs;
}
return $this-&gt;getSchemeAndHttpHost().$this-&gt;getBaseUrl().$this-&gt;getPathInfo().$qs;
}
public function getUriForPath($path)
{
return $this-&gt;getSchemeAndHttpHost().$this-&gt;getBaseUrl().$path;
}
public function getQueryString()
{
$qs = static::normalizeQueryString($this-&gt;server-&gt;get(&#039;QUERY_STRING&#039;));
return&#039;&#039;=== $qs ? null : $qs;
}
public function isSecure()
{
if (self::$trustProxy &amp;&amp; self::$trustedHeaders[self::HEADER_CLIENT_PROTO] &amp;&amp; $proto = $this-&gt;headers-&gt;get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO])) {
return in_array(strtolower($proto), array(&#039;https&#039;,&#039;on&#039;,&#039;1&#039;));
}
return&#039;on&#039;== strtolower($this-&gt;server-&gt;get(&#039;HTTPS&#039;)) || 1 == $this-&gt;server-&gt;get(&#039;HTTPS&#039;);
}
public function getHost()
{
if (self::$trustProxy &amp;&amp; self::$trustedHeaders[self::HEADER_CLIENT_HOST] &amp;&amp; $host = $this-&gt;headers-&gt;get(self::$trustedHeaders[self::HEADER_CLIENT_HOST])) {
$elements = explode(&#039;,&#039;, $host);
$host = $elements[count($elements) - 1];
} elseif (!$host = $this-&gt;headers-&gt;get(&#039;HOST&#039;)) {
if (!$host = $this-&gt;server-&gt;get(&#039;SERVER_NAME&#039;)) {
$host = $this-&gt;server-&gt;get(&#039;SERVER_ADDR&#039;,&#039;&#039;);
}
}
$host = strtolower(preg_replace(&#039;/:\d+$/&#039;,&#039;&#039;, trim($host)));
if ($host &amp;&amp; !preg_match(&#039;/^\[?(?:[a-zA-Z0-9-:\]_]+\.?)+$/&#039;, $host)) {
throw new \UnexpectedValueException(&#039;Invalid Host&#039;);
}
return $host;
}
public function setMethod($method)
{
$this-&gt;method = null;
$this-&gt;server-&gt;set(&#039;REQUEST_METHOD&#039;, $method);
}
public function getMethod()
{
if (null === $this-&gt;method) {
$this-&gt;method = strtoupper($this-&gt;server-&gt;get(&#039;REQUEST_METHOD&#039;,&#039;GET&#039;));
if (&#039;POST&#039;=== $this-&gt;method) {
if ($method = $this-&gt;headers-&gt;get(&#039;X-HTTP-METHOD-OVERRIDE&#039;)) {
$this-&gt;method = strtoupper($method);
} elseif (self::$httpMethodParameterOverride) {
$this-&gt;method = strtoupper($this-&gt;request-&gt;get(&#039;_method&#039;, $this-&gt;query-&gt;get(&#039;_method&#039;,&#039;POST&#039;)));
}
}
}
return $this-&gt;method;
}
public function getRealMethod()
{
return strtoupper($this-&gt;server-&gt;get(&#039;REQUEST_METHOD&#039;,&#039;GET&#039;));
}
public function getMimeType($format)
{
if (null === static::$formats) {
static::initializeFormats();
}
return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
}
public function getFormat($mimeType)
{
if (false !== $pos = strpos($mimeType,&#039;;&#039;)) {
$mimeType = substr($mimeType, 0, $pos);
}
if (null === static::$formats) {
static::initializeFormats();
}
foreach (static::$formats as $format =&gt; $mimeTypes) {
if (in_array($mimeType, (array) $mimeTypes)) {
return $format;
}
}
return null;
}
public function setFormat($format, $mimeTypes)
{
if (null === static::$formats) {
static::initializeFormats();
}
static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes);
}
public function getRequestFormat($default =&#039;html&#039;)
{
if (null === $this-&gt;format) {
$this-&gt;format = $this-&gt;get(&#039;_format&#039;, $default);
}
return $this-&gt;format;
}
public function setRequestFormat($format)
{
$this-&gt;format = $format;
}
public function getContentType()
{
return $this-&gt;getFormat($this-&gt;headers-&gt;get(&#039;CONTENT_TYPE&#039;));
}
public function setDefaultLocale($locale)
{
$this-&gt;defaultLocale = $locale;
if (null === $this-&gt;locale) {
$this-&gt;setPhpDefaultLocale($locale);
}
}
public function setLocale($locale)
{
$this-&gt;setPhpDefaultLocale($this-&gt;locale = $locale);
}
public function getLocale()
{
return null === $this-&gt;locale ? $this-&gt;defaultLocale : $this-&gt;locale;
}
public function isMethod($method)
{
return $this-&gt;getMethod() === strtoupper($method);
}
public function isMethodSafe()
{
return in_array($this-&gt;getMethod(), array(&#039;GET&#039;,&#039;HEAD&#039;));
}
public function getContent($asResource = false)
{
if (false === $this-&gt;content || (true === $asResource &amp;&amp; null !== $this-&gt;content)) {
throw new \LogicException(&#039;getContent() can only be called once when using the resource return type.&#039;);
}
if (true === $asResource) {
$this-&gt;content = false;
return fopen(&#039;php://input&#039;,&#039;rb&#039;);
}
if (null === $this-&gt;content) {
$this-&gt;content = file_get_contents(&#039;php://input&#039;);
}
return $this-&gt;content;
}
public function getETags()
{
return preg_split(&#039;/\s*,\s*/&#039;, $this-&gt;headers-&gt;get(&#039;if_none_match&#039;), null, PREG_SPLIT_NO_EMPTY);
}
public function isNoCache()
{
return $this-&gt;headers-&gt;hasCacheControlDirective(&#039;no-cache&#039;) ||&#039;no-cache&#039;== $this-&gt;headers-&gt;get(&#039;Pragma&#039;);
}
public function getPreferredLanguage(array $locales = null)
{
$preferredLanguages = $this-&gt;getLanguages();
if (empty($locales)) {
return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;
}
if (!$preferredLanguages) {
return $locales[0];
}
$extendedPreferredLanguages = array();
foreach ($preferredLanguages as $language) {
$extendedPreferredLanguages[] = $language;
if (false !== $position = strpos($language,&#039;_&#039;)) {
$superLanguage = substr($language, 0, $position);
if (!in_array($superLanguage, $preferredLanguages)) {
$extendedPreferredLanguages[] = $superLanguage;
}
}
}
$preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));
return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];
}
public function getLanguages()
{
if (null !== $this-&gt;languages) {
return $this-&gt;languages;
}
$languages = AcceptHeader::fromString($this-&gt;headers-&gt;get(&#039;Accept-Language&#039;))-&gt;all();
$this-&gt;languages = array();
foreach (array_keys($languages) as $lang) {
if (strstr($lang,&#039;-&#039;)) {
$codes = explode(&#039;-&#039;, $lang);
if ($codes[0] ==&#039;i&#039;) {
if (count($codes) &gt; 1) {
$lang = $codes[1];
}
} else {
for ($i = 0, $max = count($codes); $i &lt; $max; $i++) {
if ($i == 0) {
$lang = strtolower($codes[0]);
} else {
$lang .=&#039;_&#039;.strtoupper($codes[$i]);
}
}
}
}
$this-&gt;languages[] = $lang;
}
return $this-&gt;languages;
}
public function getCharsets()
{
if (null !== $this-&gt;charsets) {
return $this-&gt;charsets;
}
return $this-&gt;charsets = array_keys(AcceptHeader::fromString($this-&gt;headers-&gt;get(&#039;Accept-Charset&#039;))-&gt;all());
}
public function getAcceptableContentTypes()
{
if (null !== $this-&gt;acceptableContentTypes) {
return $this-&gt;acceptableContentTypes;
}
return $this-&gt;acceptableContentTypes = array_keys(AcceptHeader::fromString($this-&gt;headers-&gt;get(&#039;Accept&#039;))-&gt;all());
}
public function isXmlHttpRequest()
{
return&#039;XMLHttpRequest&#039;== $this-&gt;headers-&gt;get(&#039;X-Requested-With&#039;);
}
public function splitHttpAcceptHeader($header)
{
trigger_error(&#039;splitHttpAcceptHeader() is deprecated since version 2.2 and will be removed in 2.3.&#039;, E_USER_DEPRECATED);
$headers = array();
foreach (AcceptHeader::fromString($header)-&gt;all() as $item) {
$key = $item-&gt;getValue();
foreach ($item-&gt;getAttributes() as $name =&gt; $value) {
$key .= sprintf(&#039;;%s=%s&#039;, $name, $value);
}
$headers[$key] = $item-&gt;getQuality();
}
return $headers;
}
protected function prepareRequestUri()
{
$requestUri =&#039;&#039;;
if ($this-&gt;headers-&gt;has(&#039;X_ORIGINAL_URL&#039;)) {
$requestUri = $this-&gt;headers-&gt;get(&#039;X_ORIGINAL_URL&#039;);
$this-&gt;headers-&gt;remove(&#039;X_ORIGINAL_URL&#039;);
$this-&gt;server-&gt;remove(&#039;HTTP_X_ORIGINAL_URL&#039;);
$this-&gt;server-&gt;remove(&#039;UNENCODED_URL&#039;);
$this-&gt;server-&gt;remove(&#039;IIS_WasUrlRewritten&#039;);
} elseif ($this-&gt;headers-&gt;has(&#039;X_REWRITE_URL&#039;)) {
$requestUri = $this-&gt;headers-&gt;get(&#039;X_REWRITE_URL&#039;);
$this-&gt;headers-&gt;remove(&#039;X_REWRITE_URL&#039;);
} elseif ($this-&gt;server-&gt;get(&#039;IIS_WasUrlRewritten&#039;) ==&#039;1&#039;&amp;&amp; $this-&gt;server-&gt;get(&#039;UNENCODED_URL&#039;) !=&#039;&#039;) {
$requestUri = $this-&gt;server-&gt;get(&#039;UNENCODED_URL&#039;);
$this-&gt;server-&gt;remove(&#039;UNENCODED_URL&#039;);
$this-&gt;server-&gt;remove(&#039;IIS_WasUrlRewritten&#039;);
} elseif ($this-&gt;server-&gt;has(&#039;REQUEST_URI&#039;)) {
$requestUri = $this-&gt;server-&gt;get(&#039;REQUEST_URI&#039;);
$schemeAndHttpHost = $this-&gt;getSchemeAndHttpHost();
if (strpos($requestUri, $schemeAndHttpHost) === 0) {
$requestUri = substr($requestUri, strlen($schemeAndHttpHost));
}
} elseif ($this-&gt;server-&gt;has(&#039;ORIG_PATH_INFO&#039;)) {
$requestUri = $this-&gt;server-&gt;get(&#039;ORIG_PATH_INFO&#039;);
if (&#039;&#039;!= $this-&gt;server-&gt;get(&#039;QUERY_STRING&#039;)) {
$requestUri .=&#039;?&#039;.$this-&gt;server-&gt;get(&#039;QUERY_STRING&#039;);
}
$this-&gt;server-&gt;remove(&#039;ORIG_PATH_INFO&#039;);
}
$this-&gt;server-&gt;set(&#039;REQUEST_URI&#039;, $requestUri);
return $requestUri;
}
protected function prepareBaseUrl()
{
$filename = basename($this-&gt;server-&gt;get(&#039;SCRIPT_FILENAME&#039;));
if (basename($this-&gt;server-&gt;get(&#039;SCRIPT_NAME&#039;)) === $filename) {
$baseUrl = $this-&gt;server-&gt;get(&#039;SCRIPT_NAME&#039;);
} elseif (basename($this-&gt;server-&gt;get(&#039;PHP_SELF&#039;)) === $filename) {
$baseUrl = $this-&gt;server-&gt;get(&#039;PHP_SELF&#039;);
} elseif (basename($this-&gt;server-&gt;get(&#039;ORIG_SCRIPT_NAME&#039;)) === $filename) {
$baseUrl = $this-&gt;server-&gt;get(&#039;ORIG_SCRIPT_NAME&#039;); } else {
$path = $this-&gt;server-&gt;get(&#039;PHP_SELF&#039;,&#039;&#039;);
$file = $this-&gt;server-&gt;get(&#039;SCRIPT_FILENAME&#039;,&#039;&#039;);
$segs = explode(&#039;/&#039;, trim($file,&#039;/&#039;));
$segs = array_reverse($segs);
$index = 0;
$last = count($segs);
$baseUrl =&#039;&#039;;
do {
$seg = $segs[$index];
$baseUrl =&#039;/&#039;.$seg.$baseUrl;
++$index;
} while (($last &gt; $index) &amp;&amp; (false !== ($pos = strpos($path, $baseUrl))) &amp;&amp; (0 != $pos));
}
$requestUri = $this-&gt;getRequestUri();
if ($baseUrl &amp;&amp; false !== $prefix = $this-&gt;getUrlencodedPrefix($requestUri, $baseUrl)) {
return $prefix;
}
if ($baseUrl &amp;&amp; false !== $prefix = $this-&gt;getUrlencodedPrefix($requestUri, dirname($baseUrl))) {
return rtrim($prefix,&#039;/&#039;);
}
$truncatedRequestUri = $requestUri;
if (($pos = strpos($requestUri,&#039;?&#039;)) !== false) {
$truncatedRequestUri = substr($requestUri, 0, $pos);
}
$basename = basename($baseUrl);
if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
return&#039;&#039;;
}
if ((strlen($requestUri) &gt;= strlen($baseUrl)) &amp;&amp; ((false !== ($pos = strpos($requestUri, $baseUrl))) &amp;&amp; ($pos !== 0))) {
$baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));
}
return rtrim($baseUrl,&#039;/&#039;);
}
protected function prepareBasePath()
{
$filename = basename($this-&gt;server-&gt;get(&#039;SCRIPT_FILENAME&#039;));
$baseUrl = $this-&gt;getBaseUrl();
if (empty($baseUrl)) {
return&#039;&#039;;
}
if (basename($baseUrl) === $filename) {
$basePath = dirname($baseUrl);
} else {
$basePath = $baseUrl;
}
if (&#039;\\&#039;=== DIRECTORY_SEPARATOR) {
$basePath = str_replace(&#039;\\&#039;,&#039;/&#039;, $basePath);
}
return rtrim($basePath,&#039;/&#039;);
}
protected function preparePathInfo()
{
$baseUrl = $this-&gt;getBaseUrl();
if (null === ($requestUri = $this-&gt;getRequestUri())) {
return&#039;/&#039;;
}
$pathInfo =&#039;/&#039;;
if ($pos = strpos($requestUri,&#039;?&#039;)) {
$requestUri = substr($requestUri, 0, $pos);
}
if ((null !== $baseUrl) &amp;&amp; (false === ($pathInfo = substr($requestUri, strlen($baseUrl))))) {
return&#039;/&#039;;
} elseif (null === $baseUrl) {
return $requestUri;
}
return (string) $pathInfo;
}
protected static function initializeFormats()
{
static::$formats = array(&#039;html&#039;=&gt; array(&#039;text/html&#039;,&#039;application/xhtml+xml&#039;),&#039;txt&#039;=&gt; array(&#039;text/plain&#039;),&#039;js&#039;=&gt; array(&#039;application/javascript&#039;,&#039;application/x-javascript&#039;,&#039;text/javascript&#039;),&#039;css&#039;=&gt; array(&#039;text/css&#039;),&#039;json&#039;=&gt; array(&#039;application/json&#039;,&#039;application/x-json&#039;),&#039;xml&#039;=&gt; array(&#039;text/xml&#039;,&#039;application/xml&#039;,&#039;application/x-xml&#039;),&#039;rdf&#039;=&gt; array(&#039;application/rdf+xml&#039;),&#039;atom&#039;=&gt; array(&#039;application/atom+xml&#039;),&#039;rss&#039;=&gt; array(&#039;application/rss+xml&#039;),
);
}
private function setPhpDefaultLocale($locale)
{
try {
if (class_exists(&#039;Locale&#039;, false)) {
\Locale::setDefault($locale);
}
} catch (\Exception $e) {
}
}
private function getUrlencodedPrefix($string, $prefix)
{
if (0 !== strpos(rawurldecode($string), $prefix)) {
return false;
}
$len = strlen($prefix);
if (preg_match(&quot;#^(%[[:xdigit:]]{2}|.){{$len}}#&quot;, $string, $match)) {
return $match[0];
}
return false;
}
}
}
namespace Symfony\Component\HttpFoundation
{
class Response
{
public $headers;
protected $content;
protected $version;
protected $statusCode;
protected $statusText;
protected $charset;
public static $statusTexts = array(
100 =&gt;&#039;Continue&#039;,
101 =&gt;&#039;Switching Protocols&#039;,
102 =&gt;&#039;Processing&#039;, 200 =&gt;&#039;OK&#039;,
201 =&gt;&#039;Created&#039;,
202 =&gt;&#039;Accepted&#039;,
203 =&gt;&#039;Non-Authoritative Information&#039;,
204 =&gt;&#039;No Content&#039;,
205 =&gt;&#039;Reset Content&#039;,
206 =&gt;&#039;Partial Content&#039;,
207 =&gt;&#039;Multi-Status&#039;, 208 =&gt;&#039;Already Reported&#039;, 226 =&gt;&#039;IM Used&#039;, 300 =&gt;&#039;Multiple Choices&#039;,
301 =&gt;&#039;Moved Permanently&#039;,
302 =&gt;&#039;Found&#039;,
303 =&gt;&#039;See Other&#039;,
304 =&gt;&#039;Not Modified&#039;,
305 =&gt;&#039;Use Proxy&#039;,
306 =&gt;&#039;Reserved&#039;,
307 =&gt;&#039;Temporary Redirect&#039;,
308 =&gt;&#039;Permanent Redirect&#039;, 400 =&gt;&#039;Bad Request&#039;,
401 =&gt;&#039;Unauthorized&#039;,
402 =&gt;&#039;Payment Required&#039;,
403 =&gt;&#039;Forbidden&#039;,
404 =&gt;&#039;Not Found&#039;,
405 =&gt;&#039;Method Not Allowed&#039;,
406 =&gt;&#039;Not Acceptable&#039;,
407 =&gt;&#039;Proxy Authentication Required&#039;,
408 =&gt;&#039;Request Timeout&#039;,
409 =&gt;&#039;Conflict&#039;,
410 =&gt;&#039;Gone&#039;,
411 =&gt;&#039;Length Required&#039;,
412 =&gt;&#039;Precondition Failed&#039;,
413 =&gt;&#039;Request Entity Too Large&#039;,
414 =&gt;&#039;Request-URI Too Long&#039;,
415 =&gt;&#039;Unsupported Media Type&#039;,
416 =&gt;&#039;Requested Range Not Satisfiable&#039;,
417 =&gt;&#039;Expectation Failed&#039;,
418 =&gt;&#039;I\&#039;m a teapot&#039;, 422 =&gt;&#039;Unprocessable Entity&#039;, 423 =&gt;&#039;Locked&#039;, 424 =&gt;&#039;Failed Dependency&#039;, 425 =&gt;&#039;Reserved for WebDAV advanced collections expired proposal&#039;, 426 =&gt;&#039;Upgrade Required&#039;, 428 =&gt;&#039;Precondition Required&#039;, 429 =&gt;&#039;Too Many Requests&#039;, 431 =&gt;&#039;Request Header Fields Too Large&#039;, 500 =&gt;&#039;Internal Server Error&#039;,
501 =&gt;&#039;Not Implemented&#039;,
502 =&gt;&#039;Bad Gateway&#039;,
503 =&gt;&#039;Service Unavailable&#039;,
504 =&gt;&#039;Gateway Timeout&#039;,
505 =&gt;&#039;HTTP Version Not Supported&#039;,
506 =&gt;&#039;Variant Also Negotiates (Experimental)&#039;, 507 =&gt;&#039;Insufficient Storage&#039;, 508 =&gt;&#039;Loop Detected&#039;, 510 =&gt;&#039;Not Extended&#039;, 511 =&gt;&#039;Network Authentication Required&#039;, );
public function __construct($content =&#039;&#039;, $status = 200, $headers = array())
{
$this-&gt;headers = new ResponseHeaderBag($headers);
$this-&gt;setContent($content);
$this-&gt;setStatusCode($status);
$this-&gt;setProtocolVersion(&#039;1.0&#039;);
if (!$this-&gt;headers-&gt;has(&#039;Date&#039;)) {
$this-&gt;setDate(new \DateTime(null, new \DateTimeZone(&#039;UTC&#039;)));
}
}
public static function create($content =&#039;&#039;, $status = 200, $headers = array())
{
return new static($content, $status, $headers);
}
public function __toString()
{
return
sprintf(&#039;HTTP/%s %s %s&#039;, $this-&gt;version, $this-&gt;statusCode, $this-&gt;statusText).&quot;\r\n&quot;.
$this-&gt;headers.&quot;\r\n&quot;.
$this-&gt;getContent();
}
public function __clone()
{
$this-&gt;headers = clone $this-&gt;headers;
}
public function prepare(Request $request)
{
$headers = $this-&gt;headers;
if ($this-&gt;isInformational() || in_array($this-&gt;statusCode, array(204, 304))) {
$this-&gt;setContent(null);
}
if (!$headers-&gt;has(&#039;Content-Type&#039;)) {
$format = $request-&gt;getRequestFormat();
if (null !== $format &amp;&amp; $mimeType = $request-&gt;getMimeType($format)) {
$headers-&gt;set(&#039;Content-Type&#039;, $mimeType);
}
}
$charset = $this-&gt;charset ?:&#039;UTF-8&#039;;
if (!$headers-&gt;has(&#039;Content-Type&#039;)) {
$headers-&gt;set(&#039;Content-Type&#039;,&#039;text/html; charset=&#039;.$charset);
} elseif (0 === strpos($headers-&gt;get(&#039;Content-Type&#039;),&#039;text/&#039;) &amp;&amp; false === strpos($headers-&gt;get(&#039;Content-Type&#039;),&#039;charset&#039;)) {
$headers-&gt;set(&#039;Content-Type&#039;, $headers-&gt;get(&#039;Content-Type&#039;).&#039;; charset=&#039;.$charset);
}
if ($headers-&gt;has(&#039;Transfer-Encoding&#039;)) {
$headers-&gt;remove(&#039;Content-Length&#039;);
}
if ($request-&gt;isMethod(&#039;HEAD&#039;)) {
$length = $headers-&gt;get(&#039;Content-Length&#039;);
$this-&gt;setContent(null);
if ($length) {
$headers-&gt;set(&#039;Content-Length&#039;, $length);
}
}
if (&#039;HTTP/1.0&#039;!= $request-&gt;server-&gt;get(&#039;SERVER_PROTOCOL&#039;)) {
$this-&gt;setProtocolVersion(&#039;1.1&#039;);
}
if (&#039;1.0&#039;== $this-&gt;getProtocolVersion() &amp;&amp;&#039;no-cache&#039;== $this-&gt;headers-&gt;get(&#039;Cache-Control&#039;)) {
$this-&gt;headers-&gt;set(&#039;pragma&#039;,&#039;no-cache&#039;);
$this-&gt;headers-&gt;set(&#039;expires&#039;, -1);
}
$this-&gt;ensureIEOverSSLCompatibility($request);
return $this;
}
public function sendHeaders()
{
if (headers_sent()) {
return $this;
}
header(sprintf(&#039;HTTP/%s %s %s&#039;, $this-&gt;version, $this-&gt;statusCode, $this-&gt;statusText));
foreach ($this-&gt;headers-&gt;allPreserveCase() as $name =&gt; $values) {
foreach ($values as $value) {
header($name.&#039;: &#039;.$value, false);
}
}
foreach ($this-&gt;headers-&gt;getCookies() as $cookie) {
setcookie($cookie-&gt;getName(), $cookie-&gt;getValue(), $cookie-&gt;getExpiresTime(), $cookie-&gt;getPath(), $cookie-&gt;getDomain(), $cookie-&gt;isSecure(), $cookie-&gt;isHttpOnly());
}
return $this;
}
public function sendContent()
{
echo $this-&gt;content;
return $this;
}
public function send()
{
$this-&gt;sendHeaders();
$this-&gt;sendContent();
if (function_exists(&#039;fastcgi_finish_request&#039;)) {
fastcgi_finish_request();
} elseif (&#039;cli&#039;!== PHP_SAPI) {
$previous = null;
$obStatus = ob_get_status(1);
while (($level = ob_get_level()) &gt; 0 &amp;&amp; $level !== $previous) {
$previous = $level;
if ($obStatus[$level - 1] &amp;&amp; isset($obStatus[$level - 1][&#039;del&#039;]) &amp;&amp; $obStatus[$level - 1][&#039;del&#039;]) {
ob_end_flush();
}
}
flush();
}
return $this;
}
public function setContent($content)
{
if (null !== $content &amp;&amp; !is_string($content) &amp;&amp; !is_numeric($content) &amp;&amp; !is_callable(array($content,&#039;__toString&#039;))) {
throw new \UnexpectedValueException(&#039;The Response content must be a string or object implementing __toString(), &quot;&#039;.gettype($content).&#039;&quot; given.&#039;);
}
$this-&gt;content = (string) $content;
return $this;
}
public function getContent()
{
return $this-&gt;content;
}
public function setProtocolVersion($version)
{
$this-&gt;version = $version;
return $this;
}
public function getProtocolVersion()
{
return $this-&gt;version;
}
public function setStatusCode($code, $text = null)
{
$this-&gt;statusCode = $code = (int) $code;
if ($this-&gt;isInvalid()) {
throw new \InvalidArgumentException(sprintf(&#039;The HTTP status code &quot;%s&quot; is not valid.&#039;, $code));
}
if (null === $text) {
$this-&gt;statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] :&#039;&#039;;
return $this;
}
if (false === $text) {
$this-&gt;statusText =&#039;&#039;;
return $this;
}
$this-&gt;statusText = $text;
return $this;
}
public function getStatusCode()
{
return $this-&gt;statusCode;
}
public function setCharset($charset)
{
$this-&gt;charset = $charset;
return $this;
}
public function getCharset()
{
return $this-&gt;charset;
}
public function isCacheable()
{
if (!in_array($this-&gt;statusCode, array(200, 203, 300, 301, 302, 404, 410))) {
return false;
}
if ($this-&gt;headers-&gt;hasCacheControlDirective(&#039;no-store&#039;) || $this-&gt;headers-&gt;getCacheControlDirective(&#039;private&#039;)) {
return false;
}
return $this-&gt;isValidateable() || $this-&gt;isFresh();
}
public function isFresh()
{
return $this-&gt;getTtl() &gt; 0;
}
public function isValidateable()
{
return $this-&gt;headers-&gt;has(&#039;Last-Modified&#039;) || $this-&gt;headers-&gt;has(&#039;ETag&#039;);
}
public function setPrivate()
{
$this-&gt;headers-&gt;removeCacheControlDirective(&#039;public&#039;);
$this-&gt;headers-&gt;addCacheControlDirective(&#039;private&#039;);
return $this;
}
public function setPublic()
{
$this-&gt;headers-&gt;addCacheControlDirective(&#039;public&#039;);
$this-&gt;headers-&gt;removeCacheControlDirective(&#039;private&#039;);
return $this;
}
public function mustRevalidate()
{
return $this-&gt;headers-&gt;hasCacheControlDirective(&#039;must-revalidate&#039;) || $this-&gt;headers-&gt;has(&#039;proxy-revalidate&#039;);
}
public function getDate()
{
return $this-&gt;headers-&gt;getDate(&#039;Date&#039;, new \DateTime());
}
public function setDate(\DateTime $date)
{
$date-&gt;setTimezone(new \DateTimeZone(&#039;UTC&#039;));
$this-&gt;headers-&gt;set(&#039;Date&#039;, $date-&gt;format(&#039;D, d M Y H:i:s&#039;).&#039; GMT&#039;);
return $this;
}
public function getAge()
{
if (null !== $age = $this-&gt;headers-&gt;get(&#039;Age&#039;)) {
return (int) $age;
}
return max(time() - $this-&gt;getDate()-&gt;format(&#039;U&#039;), 0);
}
public function expire()
{
if ($this-&gt;isFresh()) {
$this-&gt;headers-&gt;set(&#039;Age&#039;, $this-&gt;getMaxAge());
}
return $this;
}
public function getExpires()
{
try {
return $this-&gt;headers-&gt;getDate(&#039;Expires&#039;);
} catch (\RuntimeException $e) {
return \DateTime::createFromFormat(DATE_RFC2822,&#039;Sat, 01 Jan 00 00:00:00 +0000&#039;);
}
}
public function setExpires(\DateTime $date = null)
{
if (null === $date) {
$this-&gt;headers-&gt;remove(&#039;Expires&#039;);
} else {
$date = clone $date;
$date-&gt;setTimezone(new \DateTimeZone(&#039;UTC&#039;));
$this-&gt;headers-&gt;set(&#039;Expires&#039;, $date-&gt;format(&#039;D, d M Y H:i:s&#039;).&#039; GMT&#039;);
}
return $this;
}
public function getMaxAge()
{
if ($this-&gt;headers-&gt;hasCacheControlDirective(&#039;s-maxage&#039;)) {
return (int) $this-&gt;headers-&gt;getCacheControlDirective(&#039;s-maxage&#039;);
}
if ($this-&gt;headers-&gt;hasCacheControlDirective(&#039;max-age&#039;)) {
return (int) $this-&gt;headers-&gt;getCacheControlDirective(&#039;max-age&#039;);
}
if (null !== $this-&gt;getExpires()) {
return $this-&gt;getExpires()-&gt;format(&#039;U&#039;) - $this-&gt;getDate()-&gt;format(&#039;U&#039;);
}
return null;
}
public function setMaxAge($value)
{
$this-&gt;headers-&gt;addCacheControlDirective(&#039;max-age&#039;, $value);
return $this;
}
public function setSharedMaxAge($value)
{
$this-&gt;setPublic();
$this-&gt;headers-&gt;addCacheControlDirective(&#039;s-maxage&#039;, $value);
return $this;
}
public function getTtl()
{
if (null !== $maxAge = $this-&gt;getMaxAge()) {
return $maxAge - $this-&gt;getAge();
}
return null;
}
public function setTtl($seconds)
{
$this-&gt;setSharedMaxAge($this-&gt;getAge() + $seconds);
return $this;
}
public function setClientTtl($seconds)
{
$this-&gt;setMaxAge($this-&gt;getAge() + $seconds);
return $this;
}
public function getLastModified()
{
return $this-&gt;headers-&gt;getDate(&#039;Last-Modified&#039;);
}
public function setLastModified(\DateTime $date = null)
{
if (null === $date) {
$this-&gt;headers-&gt;remove(&#039;Last-Modified&#039;);
} else {
$date = clone $date;
$date-&gt;setTimezone(new \DateTimeZone(&#039;UTC&#039;));
$this-&gt;headers-&gt;set(&#039;Last-Modified&#039;, $date-&gt;format(&#039;D, d M Y H:i:s&#039;).&#039; GMT&#039;);
}
return $this;
}
public function getEtag()
{
return $this-&gt;headers-&gt;get(&#039;ETag&#039;);
}
public function setEtag($etag = null, $weak = false)
{
if (null === $etag) {
$this-&gt;headers-&gt;remove(&#039;Etag&#039;);
} else {
if (0 !== strpos($etag,&#039;&quot;&#039;)) {
$etag =&#039;&quot;&#039;.$etag.&#039;&quot;&#039;;
}
$this-&gt;headers-&gt;set(&#039;ETag&#039;, (true === $weak ?&#039;W/&#039;:&#039;&#039;).$etag);
}
return $this;
}
public function setCache(array $options)
{
if ($diff = array_diff(array_keys($options), array(&#039;etag&#039;,&#039;last_modified&#039;,&#039;max_age&#039;,&#039;s_maxage&#039;,&#039;private&#039;,&#039;public&#039;))) {
throw new \InvalidArgumentException(sprintf(&#039;Response does not support the following options: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, array_values($diff))));
}
if (isset($options[&#039;etag&#039;])) {
$this-&gt;setEtag($options[&#039;etag&#039;]);
}
if (isset($options[&#039;last_modified&#039;])) {
$this-&gt;setLastModified($options[&#039;last_modified&#039;]);
}
if (isset($options[&#039;max_age&#039;])) {
$this-&gt;setMaxAge($options[&#039;max_age&#039;]);
}
if (isset($options[&#039;s_maxage&#039;])) {
$this-&gt;setSharedMaxAge($options[&#039;s_maxage&#039;]);
}
if (isset($options[&#039;public&#039;])) {
if ($options[&#039;public&#039;]) {
$this-&gt;setPublic();
} else {
$this-&gt;setPrivate();
}
}
if (isset($options[&#039;private&#039;])) {
if ($options[&#039;private&#039;]) {
$this-&gt;setPrivate();
} else {
$this-&gt;setPublic();
}
}
return $this;
}
public function setNotModified()
{
$this-&gt;setStatusCode(304);
$this-&gt;setContent(null);
foreach (array(&#039;Allow&#039;,&#039;Content-Encoding&#039;,&#039;Content-Language&#039;,&#039;Content-Length&#039;,&#039;Content-MD5&#039;,&#039;Content-Type&#039;,&#039;Last-Modified&#039;) as $header) {
$this-&gt;headers-&gt;remove($header);
}
return $this;
}
public function hasVary()
{
return null !== $this-&gt;headers-&gt;get(&#039;Vary&#039;);
}
public function getVary()
{
if (!$vary = $this-&gt;headers-&gt;get(&#039;Vary&#039;)) {
return array();
}
return is_array($vary) ? $vary : preg_split(&#039;/[\s,]+/&#039;, $vary);
}
public function setVary($headers, $replace = true)
{
$this-&gt;headers-&gt;set(&#039;Vary&#039;, $headers, $replace);
return $this;
}
public function isNotModified(Request $request)
{
if (!$request-&gt;isMethodSafe()) {
return false;
}
$lastModified = $request-&gt;headers-&gt;get(&#039;If-Modified-Since&#039;);
$notModified = false;
if ($etags = $request-&gt;getEtags()) {
$notModified = (in_array($this-&gt;getEtag(), $etags) || in_array(&#039;*&#039;, $etags)) &amp;&amp; (!$lastModified || $this-&gt;headers-&gt;get(&#039;Last-Modified&#039;) == $lastModified);
} elseif ($lastModified) {
$notModified = $lastModified == $this-&gt;headers-&gt;get(&#039;Last-Modified&#039;);
}
if ($notModified) {
$this-&gt;setNotModified();
}
return $notModified;
}
public function isInvalid()
{
return $this-&gt;statusCode &lt; 100 || $this-&gt;statusCode &gt;= 600;
}
public function isInformational()
{
return $this-&gt;statusCode &gt;= 100 &amp;&amp; $this-&gt;statusCode &lt; 200;
}
public function isSuccessful()
{
return $this-&gt;statusCode &gt;= 200 &amp;&amp; $this-&gt;statusCode &lt; 300;
}
public function isRedirection()
{
return $this-&gt;statusCode &gt;= 300 &amp;&amp; $this-&gt;statusCode &lt; 400;
}
public function isClientError()
{
return $this-&gt;statusCode &gt;= 400 &amp;&amp; $this-&gt;statusCode &lt; 500;
}
public function isServerError()
{
return $this-&gt;statusCode &gt;= 500 &amp;&amp; $this-&gt;statusCode &lt; 600;
}
public function isOk()
{
return 200 === $this-&gt;statusCode;
}
public function isForbidden()
{
return 403 === $this-&gt;statusCode;
}
public function isNotFound()
{
return 404 === $this-&gt;statusCode;
}
public function isRedirect($location = null)
{
return in_array($this-&gt;statusCode, array(201, 301, 302, 303, 307, 308)) &amp;&amp; (null === $location ?: $location == $this-&gt;headers-&gt;get(&#039;Location&#039;));
}
public function isEmpty()
{
return in_array($this-&gt;statusCode, array(201, 204, 304));
}
protected function ensureIEOverSSLCompatibility(Request $request)
{
if (false !== stripos($this-&gt;headers-&gt;get(&#039;Content-Disposition&#039;),&#039;attachment&#039;) &amp;&amp; preg_match(&#039;/MSIE (.*?);/i&#039;, $request-&gt;server-&gt;get(&#039;HTTP_USER_AGENT&#039;), $match) == 1 &amp;&amp; true === $request-&gt;isSecure()) {
if (intval(preg_replace(&quot;/(MSIE )(.*?);/&quot;,&quot;$2&quot;, $match[0])) &lt; 9) {
$this-&gt;headers-&gt;remove(&#039;Cache-Control&#039;);
}
}
}
}
}
namespace Symfony\Component\HttpFoundation
{
class ResponseHeaderBag extends HeaderBag
{
const COOKIES_FLAT =&#039;flat&#039;;
const COOKIES_ARRAY =&#039;array&#039;;
const DISPOSITION_ATTACHMENT =&#039;attachment&#039;;
const DISPOSITION_INLINE =&#039;inline&#039;;
protected $computedCacheControl = array();
protected $cookies = array();
protected $headerNames = array();
public function __construct(array $headers = array())
{
parent::__construct($headers);
if (!isset($this-&gt;headers[&#039;cache-control&#039;])) {
$this-&gt;set(&#039;Cache-Control&#039;,&#039;&#039;);
}
}
public function __toString()
{
$cookies =&#039;&#039;;
foreach ($this-&gt;getCookies() as $cookie) {
$cookies .=&#039;Set-Cookie: &#039;.$cookie.&quot;\r\n&quot;;
}
ksort($this-&gt;headerNames);
return parent::__toString().$cookies;
}
public function allPreserveCase()
{
return array_combine($this-&gt;headerNames, $this-&gt;headers);
}
public function replace(array $headers = array())
{
$this-&gt;headerNames = array();
parent::replace($headers);
if (!isset($this-&gt;headers[&#039;cache-control&#039;])) {
$this-&gt;set(&#039;Cache-Control&#039;,&#039;&#039;);
}
}
public function set($key, $values, $replace = true)
{
parent::set($key, $values, $replace);
$uniqueKey = strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;);
$this-&gt;headerNames[$uniqueKey] = $key;
if (in_array($uniqueKey, array(&#039;cache-control&#039;,&#039;etag&#039;,&#039;last-modified&#039;,&#039;expires&#039;))) {
$computed = $this-&gt;computeCacheControlValue();
$this-&gt;headers[&#039;cache-control&#039;] = array($computed);
$this-&gt;headerNames[&#039;cache-control&#039;] =&#039;Cache-Control&#039;;
$this-&gt;computedCacheControl = $this-&gt;parseCacheControl($computed);
}
}
public function remove($key)
{
parent::remove($key);
$uniqueKey = strtr(strtolower($key),&#039;_&#039;,&#039;-&#039;);
unset($this-&gt;headerNames[$uniqueKey]);
if (&#039;cache-control&#039;=== $uniqueKey) {
$this-&gt;computedCacheControl = array();
}
}
public function hasCacheControlDirective($key)
{
return array_key_exists($key, $this-&gt;computedCacheControl);
}
public function getCacheControlDirective($key)
{
return array_key_exists($key, $this-&gt;computedCacheControl) ? $this-&gt;computedCacheControl[$key] : null;
}
public function setCookie(Cookie $cookie)
{
$this-&gt;cookies[$cookie-&gt;getDomain()][$cookie-&gt;getPath()][$cookie-&gt;getName()] = $cookie;
}
public function removeCookie($name, $path =&#039;/&#039;, $domain = null)
{
if (null === $path) {
$path =&#039;/&#039;;
}
unset($this-&gt;cookies[$domain][$path][$name]);
if (empty($this-&gt;cookies[$domain][$path])) {
unset($this-&gt;cookies[$domain][$path]);
if (empty($this-&gt;cookies[$domain])) {
unset($this-&gt;cookies[$domain]);
}
}
}
public function getCookies($format = self::COOKIES_FLAT)
{
if (!in_array($format, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))) {
throw new \InvalidArgumentException(sprintf(&#039;Format &quot;%s&quot; invalid (%s).&#039;, $format, implode(&#039;, &#039;, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))));
}
if (self::COOKIES_ARRAY === $format) {
return $this-&gt;cookies;
}
$flattenedCookies = array();
foreach ($this-&gt;cookies as $path) {
foreach ($path as $cookies) {
foreach ($cookies as $cookie) {
$flattenedCookies[] = $cookie;
}
}
}
return $flattenedCookies;
}
public function clearCookie($name, $path =&#039;/&#039;, $domain = null)
{
$this-&gt;setCookie(new Cookie($name, null, 1, $path, $domain));
}
public function makeDisposition($disposition, $filename, $filenameFallback =&#039;&#039;)
{
if (!in_array($disposition, array(self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE))) {
throw new \InvalidArgumentException(sprintf(&#039;The disposition must be either &quot;%s&quot; or &quot;%s&quot;.&#039;, self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));
}
if (&#039;&#039;== $filenameFallback) {
$filenameFallback = $filename;
}
if (!preg_match(&#039;/^[\x20-\x7e]*$/&#039;, $filenameFallback)) {
throw new \InvalidArgumentException(&#039;The filename fallback must only contain ASCII characters.&#039;);
}
if (false !== strpos($filenameFallback,&#039;%&#039;)) {
throw new \InvalidArgumentException(&#039;The filename fallback cannot contain the &quot;%&quot; character.&#039;);
}
if (false !== strpos($filename,&#039;/&#039;) || false !== strpos($filename,&#039;\\&#039;) || false !== strpos($filenameFallback,&#039;/&#039;) || false !== strpos($filenameFallback,&#039;\\&#039;)) {
throw new \InvalidArgumentException(&#039;The filename and the fallback cannot contain the &quot;/&quot; and &quot;\\&quot; characters.&#039;);
}
$output = sprintf(&#039;%s; filename=&quot;%s&quot;&#039;, $disposition, str_replace(&#039;&quot;&#039;,&#039;\\&quot;&#039;, $filenameFallback));
if ($filename !== $filenameFallback) {
$output .= sprintf(&quot;; filename*=utf-8&#039;&#039;%s&quot;, rawurlencode($filename));
}
return $output;
}
protected function computeCacheControlValue()
{
if (!$this-&gt;cacheControl &amp;&amp; !$this-&gt;has(&#039;ETag&#039;) &amp;&amp; !$this-&gt;has(&#039;Last-Modified&#039;) &amp;&amp; !$this-&gt;has(&#039;Expires&#039;)) {
return&#039;no-cache&#039;;
}
if (!$this-&gt;cacheControl) {
return&#039;private, must-revalidate&#039;;
}
$header = $this-&gt;getCacheControlHeader();
if (isset($this-&gt;cacheControl[&#039;public&#039;]) || isset($this-&gt;cacheControl[&#039;private&#039;])) {
return $header;
}
if (!isset($this-&gt;cacheControl[&#039;s-maxage&#039;])) {
return $header.&#039;, private&#039;;
}
return $header;
}
}
}
namespace Symfony\Component\Config
{
class FileLocator implements FileLocatorInterface
{
protected $paths;
public function __construct($paths = array())
{
$this-&gt;paths = (array) $paths;
}
public function locate($name, $currentPath = null, $first = true)
{
if ($this-&gt;isAbsolutePath($name)) {
if (!file_exists($name)) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist.&#039;, $name));
}
return $name;
}
$filepaths = array();
if (null !== $currentPath &amp;&amp; file_exists($file = $currentPath.DIRECTORY_SEPARATOR.$name)) {
if (true === $first) {
return $file;
}
$filepaths[] = $file;
}
foreach ($this-&gt;paths as $path) {
if (file_exists($file = $path.DIRECTORY_SEPARATOR.$name)) {
if (true === $first) {
return $file;
}
$filepaths[] = $file;
}
}
if (!$filepaths) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist (in: %s%s).&#039;, $name, null !== $currentPath ? $currentPath.&#039;, &#039;:&#039;&#039;, implode(&#039;, &#039;, $this-&gt;paths)));
}
return array_values(array_unique($filepaths));
}
private function isAbsolutePath($file)
{
if ($file[0] ==&#039;/&#039;|| $file[0] ==&#039;\\&#039;|| (strlen($file) &gt; 3 &amp;&amp; ctype_alpha($file[0])
&amp;&amp; $file[1] ==&#039;:&#039;&amp;&amp; ($file[2] ==&#039;\\&#039;|| $file[2] ==&#039;/&#039;)
)
|| null !== parse_url($file, PHP_URL_SCHEME)
) {
return true;
}
return false;
}
}
}
namespace Symfony\Component\EventDispatcher
{
class Event
{
private $propagationStopped = false;
private $dispatcher;
private $name;
public function isPropagationStopped()
{
return $this-&gt;propagationStopped;
}
public function stopPropagation()
{
$this-&gt;propagationStopped = true;
}
public function setDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;dispatcher = $dispatcher;
}
public function getDispatcher()
{
return $this-&gt;dispatcher;
}
public function getName()
{
return $this-&gt;name;
}
public function setName($name)
{
$this-&gt;name = $name;
}
}
}
namespace Symfony\Component\EventDispatcher
{
interface EventDispatcherInterface
{
public function dispatch($eventName, Event $event = null);
public function addListener($eventName, $listener, $priority = 0);
public function addSubscriber(EventSubscriberInterface $subscriber);
public function removeListener($eventName, $listener);
public function removeSubscriber(EventSubscriberInterface $subscriber);
public function getListeners($eventName = null);
public function hasListeners($eventName = null);
}
}
namespace Symfony\Component\EventDispatcher
{
class EventDispatcher implements EventDispatcherInterface
{
private $listeners = array();
private $sorted = array();
public function dispatch($eventName, Event $event = null)
{
if (null === $event) {
$event = new Event();
}
$event-&gt;setDispatcher($this);
$event-&gt;setName($eventName);
if (!isset($this-&gt;listeners[$eventName])) {
return $event;
}
$this-&gt;doDispatch($this-&gt;getListeners($eventName), $eventName, $event);
return $event;
}
public function getListeners($eventName = null)
{
if (null !== $eventName) {
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
return $this-&gt;sorted[$eventName];
}
foreach (array_keys($this-&gt;listeners) as $eventName) {
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
}
return $this-&gt;sorted;
}
public function hasListeners($eventName = null)
{
return (Boolean) count($this-&gt;getListeners($eventName));
}
public function addListener($eventName, $listener, $priority = 0)
{
$this-&gt;listeners[$eventName][$priority][] = $listener;
unset($this-&gt;sorted[$eventName]);
}
public function removeListener($eventName, $listener)
{
if (!isset($this-&gt;listeners[$eventName])) {
return;
}
foreach ($this-&gt;listeners[$eventName] as $priority =&gt; $listeners) {
if (false !== ($key = array_search($listener, $listeners, true))) {
unset($this-&gt;listeners[$eventName][$priority][$key], $this-&gt;sorted[$eventName]);
}
}
}
public function addSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;addListener($eventName, array($subscriber, $params));
} elseif (is_string($params[0])) {
$this-&gt;addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function removeSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_array($params) &amp;&amp; is_array($params[0])) {
foreach ($params as $listener) {
$this-&gt;removeListener($eventName, array($subscriber, $listener[0]));
}
} else {
$this-&gt;removeListener($eventName, array($subscriber, is_string($params) ? $params : $params[0]));
}
}
}
protected function doDispatch($listeners, $eventName, Event $event)
{
foreach ($listeners as $listener) {
call_user_func($listener, $event);
if ($event-&gt;isPropagationStopped()) {
break;
}
}
}
private function sortListeners($eventName)
{
$this-&gt;sorted[$eventName] = array();
if (isset($this-&gt;listeners[$eventName])) {
krsort($this-&gt;listeners[$eventName]);
$this-&gt;sorted[$eventName] = call_user_func_array(&#039;array_merge&#039;, $this-&gt;listeners[$eventName]);
}
}
}
}
namespace Symfony\Component\EventDispatcher
{
use Symfony\Component\DependencyInjection\ContainerInterface;
class ContainerAwareEventDispatcher extends EventDispatcher
{
private $container;
private $listenerIds = array();
private $listeners = array();
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function addListenerService($eventName, $callback, $priority = 0)
{
if (!is_array($callback) || 2 !== count($callback)) {
throw new \InvalidArgumentException(&#039;Expected an array(&quot;service&quot;, &quot;method&quot;) argument&#039;);
}
$this-&gt;listenerIds[$eventName][] = array($callback[0], $callback[1], $priority);
}
public function removeListener($eventName, $listener)
{
$this-&gt;lazyLoad($eventName);
if (isset($this-&gt;listeners[$eventName])) {
foreach ($this-&gt;listeners[$eventName] as $key =&gt; $l) {
foreach ($this-&gt;listenerIds[$eventName] as $i =&gt; $args) {
list($serviceId, $method, $priority) = $args;
if ($key === $serviceId.&#039;.&#039;.$method) {
if ($listener === array($l, $method)) {
unset($this-&gt;listeners[$eventName][$key]);
if (empty($this-&gt;listeners[$eventName])) {
unset($this-&gt;listeners[$eventName]);
}
unset($this-&gt;listenerIds[$eventName][$i]);
if (empty($this-&gt;listenerIds[$eventName])) {
unset($this-&gt;listenerIds[$eventName]);
}
}
}
}
}
}
parent::removeListener($eventName, $listener);
}
public function hasListeners($eventName = null)
{
if (null === $eventName) {
return (Boolean) count($this-&gt;listenerIds) || (Boolean) count($this-&gt;listeners);
}
if (isset($this-&gt;listenerIds[$eventName])) {
return true;
}
return parent::hasListeners($eventName);
}
public function getListeners($eventName = null)
{
if (null === $eventName) {
foreach (array_keys($this-&gt;listenerIds) as $serviceEventName) {
$this-&gt;lazyLoad($serviceEventName);
}
} else {
$this-&gt;lazyLoad($eventName);
}
return parent::getListeners($eventName);
}
public function addSubscriberService($serviceId, $class)
{
foreach ($class::getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params, 0);
} elseif (is_string($params[0])) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params[0], isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $listener[0], isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function dispatch($eventName, Event $event = null)
{
$this-&gt;lazyLoad($eventName);
return parent::dispatch($eventName, $event);
}
public function getContainer()
{
return $this-&gt;container;
}
protected function lazyLoad($eventName)
{
if (isset($this-&gt;listenerIds[$eventName])) {
foreach ($this-&gt;listenerIds[$eventName] as $args) {
list($serviceId, $method, $priority) = $args;
$listener = $this-&gt;container-&gt;get($serviceId);
$key = $serviceId.&#039;.&#039;.$method;
if (!isset($this-&gt;listeners[$eventName][$key])) {
$this-&gt;addListener($eventName, array($listener, $method), $priority);
} elseif ($listener !== $this-&gt;listeners[$eventName][$key]) {
parent::removeListener($eventName, array($this-&gt;listeners[$eventName][$key], $method));
$this-&gt;addListener($eventName, array($listener, $method), $priority);
}
$this-&gt;listeners[$eventName][$key] = $listener;
}
}
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class ResponseListener implements EventSubscriberInterface
{
private $charset;
public function __construct($charset)
{
$this-&gt;charset = $charset;
}
public function onKernelResponse(FilterResponseEvent $event)
{
if (HttpKernelInterface::MASTER_REQUEST !== $event-&gt;getRequestType()) {
return;
}
$response = $event-&gt;getResponse();
if (null === $response-&gt;getCharset()) {
$response-&gt;setCharset($this-&gt;charset);
}
$response-&gt;prepare($event-&gt;getRequest());
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::RESPONSE =&gt;&#039;onKernelResponse&#039;,
);
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
use Symfony\Component\Routing\Matcher\RequestMatcherInterface;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class RouterListener implements EventSubscriberInterface
{
private $matcher;
private $context;
private $logger;
public function __construct($matcher, RequestContext $context = null, LoggerInterface $logger = null)
{
if (!$matcher instanceof UrlMatcherInterface &amp;&amp; !$matcher instanceof RequestMatcherInterface) {
throw new \InvalidArgumentException(&#039;Matcher must either implement UrlMatcherInterface or RequestMatcherInterface.&#039;);
}
if (null === $context &amp;&amp; !$matcher instanceof RequestContextAwareInterface) {
throw new \InvalidArgumentException(&#039;You must either pass a RequestContext or the matcher must implement RequestContextAwareInterface.&#039;);
}
$this-&gt;matcher = $matcher;
$this-&gt;context = $context ?: $matcher-&gt;getContext();
$this-&gt;logger = $logger;
}
public function onKernelRequest(GetResponseEvent $event)
{
$request = $event-&gt;getRequest();
$this-&gt;context-&gt;fromRequest($request);
if ($request-&gt;attributes-&gt;has(&#039;_controller&#039;)) {
return;
}
try {
if ($this-&gt;matcher instanceof RequestMatcherInterface) {
$parameters = $this-&gt;matcher-&gt;matchRequest($request);
} else {
$parameters = $this-&gt;matcher-&gt;match($request-&gt;getPathInfo());
}
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;info(sprintf(&#039;Matched route &quot;%s&quot; (parameters: %s)&#039;, $parameters[&#039;_route&#039;], $this-&gt;parametersToString($parameters)));
}
$request-&gt;attributes-&gt;add($parameters);
unset($parameters[&#039;_route&#039;]);
unset($parameters[&#039;_controller&#039;]);
$request-&gt;attributes-&gt;set(&#039;_route_params&#039;, $parameters);
} catch (ResourceNotFoundException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo());
throw new NotFoundHttpException($message, $e);
} catch (MethodNotAllowedException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;: Method Not Allowed (Allow: %s)&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo(), strtoupper(implode(&#039;, &#039;, $e-&gt;getAllowedMethods())));
throw new MethodNotAllowedHttpException($e-&gt;getAllowedMethods(), $message, $e);
}
}
private function parametersToString(array $parameters)
{
$pieces = array();
foreach ($parameters as $key =&gt; $val) {
$pieces[] = sprintf(&#039;&quot;%s&quot;: &quot;%s&quot;&#039;, $key, (is_string($val) ? $val : json_encode($val)));
}
return implode(&#039;, &#039;, $pieces);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(array(&#039;onKernelRequest&#039;, 32)),
);
}
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Symfony\Component\HttpFoundation\Request;
interface ControllerResolverInterface
{
public function getController(Request $request);
public function getArguments(Request $request, $controller);
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpFoundation\Request;
class ControllerResolver implements ControllerResolverInterface
{
private $logger;
public function __construct(LoggerInterface $logger = null)
{
$this-&gt;logger = $logger;
}
public function getController(Request $request)
{
if (!$controller = $request-&gt;attributes-&gt;get(&#039;_controller&#039;)) {
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;warning(&#039;Unable to look for the controller as the &quot;_controller&quot; parameter is missing&#039;);
}
return false;
}
if (is_array($controller) || (is_object($controller) &amp;&amp; method_exists($controller,&#039;__invoke&#039;))) {
return $controller;
}
if (false === strpos($controller,&#039;:&#039;)) {
if (method_exists($controller,&#039;__invoke&#039;)) {
return new $controller;
} elseif (function_exists($controller)) {
return $controller;
}
}
list($controller, $method) = $this-&gt;createController($controller);
if (!method_exists($controller, $method)) {
throw new \InvalidArgumentException(sprintf(&#039;Method &quot;%s::%s&quot; does not exist.&#039;, get_class($controller), $method));
}
return array($controller, $method);
}
public function getArguments(Request $request, $controller)
{
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} elseif (is_object($controller) &amp;&amp; !$controller instanceof \Closure) {
$r = new \ReflectionObject($controller);
$r = $r-&gt;getMethod(&#039;__invoke&#039;);
} else {
$r = new \ReflectionFunction($controller);
}
return $this-&gt;doGetArguments($request, $controller, $r-&gt;getParameters());
}
protected function doGetArguments(Request $request, $controller, array $parameters)
{
$attributes = $request-&gt;attributes-&gt;all();
$arguments = array();
foreach ($parameters as $param) {
if (array_key_exists($param-&gt;name, $attributes)) {
$arguments[] = $attributes[$param-&gt;name];
} elseif ($param-&gt;getClass() &amp;&amp; $param-&gt;getClass()-&gt;isInstance($request)) {
$arguments[] = $request;
} elseif ($param-&gt;isDefaultValueAvailable()) {
$arguments[] = $param-&gt;getDefaultValue();
} else {
if (is_array($controller)) {
$repr = sprintf(&#039;%s::%s()&#039;, get_class($controller[0]), $controller[1]);
} elseif (is_object($controller)) {
$repr = get_class($controller);
} else {
$repr = $controller;
}
throw new \RuntimeException(sprintf(&#039;Controller &quot;%s&quot; requires that you provide a value for the &quot;$%s&quot; argument (because there is no default value or because there is a non optional argument after this one).&#039;, $repr, $param-&gt;name));
}
}
return $arguments;
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find controller &quot;%s&quot;.&#039;, $controller));
}
list($class, $method) = explode(&#039;::&#039;, $controller, 2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
return array(new $class(), $method);
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\Event;
class KernelEvent extends Event
{
private $kernel;
private $request;
private $requestType;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType)
{
$this-&gt;kernel = $kernel;
$this-&gt;request = $request;
$this-&gt;requestType = $requestType;
}
public function getKernel()
{
return $this-&gt;kernel;
}
public function getRequest()
{
return $this-&gt;request;
}
public function getRequestType()
{
return $this-&gt;requestType;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class FilterControllerEvent extends KernelEvent
{
private $controller;
public function __construct(HttpKernelInterface $kernel, $controller, Request $request, $requestType)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setController($controller);
}
public function getController()
{
return $this-&gt;controller;
}
public function setController($controller)
{
if (!is_callable($controller)) {
throw new \LogicException(sprintf(&#039;The controller must be a callable (%s given).&#039;, $this-&gt;varToString($controller)));
}
$this-&gt;controller = $controller;
}
private function varToString($var)
{
if (is_object($var)) {
return sprintf(&#039;Object(%s)&#039;, get_class($var));
}
if (is_array($var)) {
$a = array();
foreach ($var as $k =&gt; $v) {
$a[] = sprintf(&#039;%s =&gt; %s&#039;, $k, $this-&gt;varToString($v));
}
return sprintf(&quot;Array(%s)&quot;, implode(&#039;, &#039;, $a));
}
if (is_resource($var)) {
return sprintf(&#039;Resource(%s)&#039;, get_resource_type($var));
}
if (null === $var) {
return&#039;null&#039;;
}
if (false === $var) {
return&#039;false&#039;;
}
if (true === $var) {
return&#039;true&#039;;
}
return (string) $var;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
class FilterResponseEvent extends KernelEvent
{
private $response;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, Response $response)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setResponse($response);
}
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpFoundation\Response;
class GetResponseEvent extends KernelEvent
{
private $response;
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
$this-&gt;stopPropagation();
}
public function hasResponse()
{
return null !== $this-&gt;response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForControllerResultEvent extends GetResponseEvent
{
private $controllerResult;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, $controllerResult)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;controllerResult = $controllerResult;
}
public function getControllerResult()
{
return $this-&gt;controllerResult;
}
public function setControllerResult($controllerResult)
{
$this-&gt;controllerResult = $controllerResult;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForExceptionEvent extends GetResponseEvent
{
private $exception;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, \Exception $e)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setException($e);
}
public function getException()
{
return $this-&gt;exception;
}
public function setException(\Exception $exception)
{
$this-&gt;exception = $exception;
}
}
}
namespace Symfony\Component\HttpKernel
{
final class KernelEvents
{
const REQUEST =&#039;kernel.request&#039;;
const EXCEPTION =&#039;kernel.exception&#039;;
const VIEW =&#039;kernel.view&#039;;
const CONTROLLER =&#039;kernel.controller&#039;;
const RESPONSE =&#039;kernel.response&#039;;
const TERMINATE =&#039;kernel.terminate&#039;;
}
}
namespace Symfony\Component\HttpKernel\Config
{
use Symfony\Component\Config\FileLocator as BaseFileLocator;
use Symfony\Component\HttpKernel\KernelInterface;
class FileLocator extends BaseFileLocator
{
private $kernel;
private $path;
public function __construct(KernelInterface $kernel, $path = null, array $paths = array())
{
$this-&gt;kernel = $kernel;
if (null !== $path) {
$this-&gt;path = $path;
$paths[] = $path;
}
parent::__construct($paths);
}
public function locate($file, $currentPath = null, $first = true)
{
if (&#039;@&#039;=== $file[0]) {
return $this-&gt;kernel-&gt;locateResource($file, $this-&gt;path, $first);
}
return parent::locate($file, $currentPath, $first);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Symfony\Component\HttpKernel\KernelInterface;
class ControllerNameParser
{
protected $kernel;
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
}
public function parse($controller)
{
if (3 != count($parts = explode(&#039;:&#039;, $controller))) {
throw new \InvalidArgumentException(sprintf(&#039;The &quot;%s&quot; controller is not a valid a:b:c controller string.&#039;, $controller));
}
list($bundle, $controller, $action) = $parts;
$controller = str_replace(&#039;/&#039;,&#039;\\&#039;, $controller);
$bundles = array();
foreach ($this-&gt;kernel-&gt;getBundle($bundle, false) as $b) {
$try = $b-&gt;getNamespace().&#039;\\Controller\\&#039;.$controller.&#039;Controller&#039;;
if (class_exists($try)) {
return $try.&#039;::&#039;.$action.&#039;Action&#039;;
}
$bundles[] = $b-&gt;getName();
$msg = sprintf(&#039;Unable to find controller &quot;%s:%s&quot; - class &quot;%s&quot; does not exist.&#039;, $bundle, $controller, $try);
}
if (count($bundles) &gt; 1) {
$msg = sprintf(&#039;Unable to find controller &quot;%s:%s&quot; in bundles %s.&#039;, $bundle, $controller, implode(&#039;, &#039;, $bundles));
}
throw new \InvalidArgumentException($msg);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Controller\ControllerResolver as BaseControllerResolver;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
class ControllerResolver extends BaseControllerResolver
{
protected $container;
protected $parser;
public function __construct(ContainerInterface $container, ControllerNameParser $parser, LoggerInterface $logger = null)
{
$this-&gt;container = $container;
$this-&gt;parser = $parser;
parent::__construct($logger);
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
$count = substr_count($controller,&#039;:&#039;);
if (2 == $count) {
$controller = $this-&gt;parser-&gt;parse($controller);
} elseif (1 == $count) {
list($service, $method) = explode(&#039;:&#039;, $controller, 2);
return array($this-&gt;container-&gt;get($service), $method);
} else {
throw new \LogicException(sprintf(&#039;Unable to parse the controller name &quot;%s&quot;.&#039;, $controller));
}
}
list($class, $method) = explode(&#039;::&#039;, $controller, 2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
$controller = new $class();
if ($controller instanceof ContainerAwareInterface) {
$controller-&gt;setContainer($this-&gt;container);
}
return array($controller, $method);
}
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\Request;
interface AccessMapInterface
{
public function getPatterns(Request $request);
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\RequestMatcherInterface;
use Symfony\Component\HttpFoundation\Request;
class AccessMap implements AccessMapInterface
{
private $map = array();
public function add(RequestMatcherInterface $requestMatcher, array $roles = array(), $channel = null)
{
$this-&gt;map[] = array($requestMatcher, $roles, $channel);
}
public function getPatterns(Request $request)
{
foreach ($this-&gt;map as $elements) {
if (null === $elements[0] || $elements[0]-&gt;matches($request)) {
return array($elements[1], $elements[2]);
}
}
return array(null, null);
}
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class Firewall implements EventSubscriberInterface
{
private $map;
private $dispatcher;
public function __construct(FirewallMapInterface $map, EventDispatcherInterface $dispatcher)
{
$this-&gt;map = $map;
$this-&gt;dispatcher = $dispatcher;
}
public function onKernelRequest(GetResponseEvent $event)
{
if (HttpKernelInterface::MASTER_REQUEST !== $event-&gt;getRequestType()) {
return;
}
list($listeners, $exception) = $this-&gt;map-&gt;getListeners($event-&gt;getRequest());
if (null !== $exception) {
$exception-&gt;register($this-&gt;dispatcher);
}
foreach ($listeners as $listener) {
$listener-&gt;handle($event);
if ($event-&gt;hasResponse()) {
break;
}
}
}
public static function getSubscribedEvents()
{
return array(KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 8));
}
}
}
namespace Symfony\Component\Security\Core
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface SecurityContextInterface
{
const ACCESS_DENIED_ERROR =&#039;_security.403_error&#039;;
const AUTHENTICATION_ERROR =&#039;_security.last_error&#039;;
const LAST_USERNAME =&#039;_security.last_username&#039;;
public function getToken();
public function setToken(TokenInterface $token = null);
public function isGranted($attributes, $object = null);
}
}
namespace Symfony\Component\Security\Core
{
use Symfony\Component\Security\Core\Exception\AuthenticationCredentialsNotFoundException;
use Symfony\Component\Security\Core\Authorization\AccessDecisionManagerInterface;
use Symfony\Component\Security\Core\Authentication\AuthenticationManagerInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class SecurityContext implements SecurityContextInterface
{
private $token;
private $accessDecisionManager;
private $authenticationManager;
private $alwaysAuthenticate;
public function __construct(AuthenticationManagerInterface $authenticationManager, AccessDecisionManagerInterface $accessDecisionManager, $alwaysAuthenticate = false)
{
$this-&gt;authenticationManager = $authenticationManager;
$this-&gt;accessDecisionManager = $accessDecisionManager;
$this-&gt;alwaysAuthenticate = $alwaysAuthenticate;
}
final public function isGranted($attributes, $object = null)
{
if (null === $this-&gt;token) {
throw new AuthenticationCredentialsNotFoundException(&#039;The security context contains no authentication token. One possible reason may be that there is no firewall configured for this URL.&#039;);
}
if ($this-&gt;alwaysAuthenticate || !$this-&gt;token-&gt;isAuthenticated()) {
$this-&gt;token = $this-&gt;authenticationManager-&gt;authenticate($this-&gt;token);
}
if (!is_array($attributes)) {
$attributes = array($attributes);
}
return $this-&gt;accessDecisionManager-&gt;decide($this-&gt;token, $attributes, $object);
}
public function getToken()
{
return $this-&gt;token;
}
public function setToken(TokenInterface $token = null)
{
$this-&gt;token = $token;
}
}
}
namespace Symfony\Component\Security\Core\User
{
use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
interface UserProviderInterface
{
public function loadUserByUsername($username);
public function refreshUser(UserInterface $user);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
interface AuthenticationManagerInterface
{
public function authenticate(TokenInterface $token);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Event\AuthenticationFailureEvent;
use Symfony\Component\Security\Core\Event\AuthenticationEvent;
use Symfony\Component\Security\Core\AuthenticationEvents;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Security\Core\Exception\AccountStatusException;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\ProviderNotFoundException;
use Symfony\Component\Security\Core\Authentication\Provider\AuthenticationProviderInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AuthenticationProviderManager implements AuthenticationManagerInterface
{
private $providers;
private $eraseCredentials;
private $eventDispatcher;
public function __construct(array $providers, $eraseCredentials = true)
{
if (!$providers) {
throw new \InvalidArgumentException(&#039;You must at least add one authentication provider.&#039;);
}
$this-&gt;providers = $providers;
$this-&gt;eraseCredentials = (Boolean) $eraseCredentials;
}
public function setEventDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;eventDispatcher = $dispatcher;
}
public function authenticate(TokenInterface $token)
{
$lastException = null;
$result = null;
foreach ($this-&gt;providers as $provider) {
if (!$provider-&gt;supports($token)) {
continue;
}
try {
$result = $provider-&gt;authenticate($token);
if (null !== $result) {
break;
}
} catch (AccountStatusException $e) {
$e-&gt;setToken($token);
throw $e;
} catch (AuthenticationException $e) {
$lastException = $e;
}
}
if (null !== $result) {
if (true === $this-&gt;eraseCredentials) {
$result-&gt;eraseCredentials();
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_SUCCESS, new AuthenticationEvent($result));
}
return $result;
}
if (null === $lastException) {
$lastException = new ProviderNotFoundException(sprintf(&#039;No Authentication Provider found for token of class &quot;%s&quot;.&#039;, get_class($token)));
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_FAILURE, new AuthenticationFailureEvent($token, $lastException));
}
$lastException-&gt;setToken($token);
throw $lastException;
}
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface AccessDecisionManagerInterface
{
public function decide(TokenInterface $token, array $attributes, $object = null);
public function supportsAttribute($attribute);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authorization\Voter\VoterInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AccessDecisionManager implements AccessDecisionManagerInterface
{
private $voters;
private $strategy;
private $allowIfAllAbstainDecisions;
private $allowIfEqualGrantedDeniedDecisions;
public function __construct(array $voters, $strategy =&#039;affirmative&#039;, $allowIfAllAbstainDecisions = false, $allowIfEqualGrantedDeniedDecisions = true)
{
if (!$voters) {
throw new \InvalidArgumentException(&#039;You must at least add one voter.&#039;);
}
$this-&gt;voters = $voters;
$this-&gt;strategy =&#039;decide&#039;.ucfirst($strategy);
$this-&gt;allowIfAllAbstainDecisions = (Boolean) $allowIfAllAbstainDecisions;
$this-&gt;allowIfEqualGrantedDeniedDecisions = (Boolean) $allowIfEqualGrantedDeniedDecisions;
}
public function decide(TokenInterface $token, array $attributes, $object = null)
{
return $this-&gt;{$this-&gt;strategy}($token, $attributes, $object);
}
public function supportsAttribute($attribute)
{
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsAttribute($attribute)) {
return true;
}
}
return false;
}
public function supportsClass($class)
{
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsClass($class)) {
return true;
}
}
return false;
}
private function decideAffirmative(TokenInterface $token, array $attributes, $object = null)
{
$deny = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
return true;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
default:
break;
}
}
if ($deny &gt; 0) {
return false;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideConsensus(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
$deny = 0;
$abstain = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
default:
++$abstain;
break;
}
}
if ($grant &gt; $deny) {
return true;
}
if ($deny &gt; $grant) {
return false;
}
if ($grant == $deny &amp;&amp; $grant != 0) {
return $this-&gt;allowIfEqualGrantedDeniedDecisions;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideUnanimous(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
foreach ($attributes as $attribute) {
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, array($attribute));
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
return false;
default:
break;
}
}
}
if ($grant &gt; 0) {
return true;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
}
}
namespace Symfony\Component\Security\Core\Authorization\Voter
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface VoterInterface
{
const ACCESS_GRANTED = 1;
const ACCESS_ABSTAIN = 0;
const ACCESS_DENIED = -1;
public function supportsAttribute($attribute);
public function supportsClass($class);
public function vote(TokenInterface $token, $object, array $attributes);
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\Request;
interface FirewallMapInterface
{
public function getListeners(Request $request);
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\FirewallMapInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\DependencyInjection\ContainerInterface;
class FirewallMap implements FirewallMapInterface
{
protected $container;
protected $map;
public function __construct(ContainerInterface $container, array $map)
{
$this-&gt;container = $container;
$this-&gt;map = $map;
}
public function getListeners(Request $request)
{
foreach ($this-&gt;map as $contextId =&gt; $requestMatcher) {
if (null === $requestMatcher || $requestMatcher-&gt;matches($request)) {
return $this-&gt;container-&gt;get($contextId)-&gt;getContext();
}
}
return array(array(), null);
}
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\Firewall\ExceptionListener;
class FirewallContext
{
private $listeners;
private $exceptionListener;
public function __construct(array $listeners, ExceptionListener $exceptionListener = null)
{
$this-&gt;listeners = $listeners;
$this-&gt;exceptionListener = $exceptionListener;
}
public function getContext()
{
return array($this-&gt;listeners, $this-&gt;exceptionListener);
}
}
}
namespace Symfony\Component\HttpFoundation
{
interface RequestMatcherInterface
{
public function matches(Request $request);
}
}
namespace Symfony\Component\HttpFoundation
{
class RequestMatcher implements RequestMatcherInterface
{
private $path;
private $host;
private $methods = array();
private $ip;
private $attributes = array();
public function __construct($path = null, $host = null, $methods = null, $ip = null, array $attributes = array())
{
$this-&gt;matchPath($path);
$this-&gt;matchHost($host);
$this-&gt;matchMethod($methods);
$this-&gt;matchIp($ip);
foreach ($attributes as $k =&gt; $v) {
$this-&gt;matchAttribute($k, $v);
}
}
public function matchHost($regexp)
{
$this-&gt;host = $regexp;
}
public function matchPath($regexp)
{
$this-&gt;path = $regexp;
}
public function matchIp($ip)
{
$this-&gt;ip = $ip;
}
public function matchMethod($method)
{
$this-&gt;methods = array_map(&#039;strtoupper&#039;, (array) $method);
}
public function matchAttribute($key, $regexp)
{
$this-&gt;attributes[$key] = $regexp;
}
public function matches(Request $request)
{
if ($this-&gt;methods &amp;&amp; !in_array($request-&gt;getMethod(), $this-&gt;methods)) {
return false;
}
foreach ($this-&gt;attributes as $key =&gt; $pattern) {
if (!preg_match(&#039;#&#039;.str_replace(&#039;#&#039;,&#039;\\#&#039;, $pattern).&#039;#&#039;, $request-&gt;attributes-&gt;get($key))) {
return false;
}
}
if (null !== $this-&gt;path) {
$path = str_replace(&#039;#&#039;,&#039;\\#&#039;, $this-&gt;path);
if (!preg_match(&#039;#&#039;.$path.&#039;#&#039;, rawurldecode($request-&gt;getPathInfo()))) {
return false;
}
}
if (null !== $this-&gt;host &amp;&amp; !preg_match(&#039;#&#039;.str_replace(&#039;#&#039;,&#039;\\#&#039;, $this-&gt;host).&#039;#i&#039;, $request-&gt;getHost())) {
return false;
}
if (null !== $this-&gt;ip &amp;&amp; !IpUtils::checkIp($request-&gt;getClientIp(), $this-&gt;ip)) {
return false;
}
return true;
}
}
}
namespace
{
class Twig_Environment
{
const VERSION =&#039;1.13.0-DEV&#039;;
protected $charset;
protected $loader;
protected $debug;
protected $autoReload;
protected $cache;
protected $lexer;
protected $parser;
protected $compiler;
protected $baseTemplateClass;
protected $extensions;
protected $parsers;
protected $visitors;
protected $filters;
protected $tests;
protected $functions;
protected $globals;
protected $runtimeInitialized;
protected $extensionInitialized;
protected $loadedTemplates;
protected $strictVariables;
protected $unaryOperators;
protected $binaryOperators;
protected $templateClassPrefix =&#039;__TwigTemplate_&#039;;
protected $functionCallbacks;
protected $filterCallbacks;
protected $staging;
public function __construct(Twig_LoaderInterface $loader = null, $options = array())
{
if (null !== $loader) {
$this-&gt;setLoader($loader);
}
$options = array_merge(array(&#039;debug&#039;=&gt; false,&#039;charset&#039;=&gt;&#039;UTF-8&#039;,&#039;base_template_class&#039;=&gt;&#039;Twig_Template&#039;,&#039;strict_variables&#039;=&gt; false,&#039;autoescape&#039;=&gt;&#039;html&#039;,&#039;cache&#039;=&gt; false,&#039;auto_reload&#039;=&gt; null,&#039;optimizations&#039;=&gt; -1,
), $options);
$this-&gt;debug = (bool) $options[&#039;debug&#039;];
$this-&gt;charset = $options[&#039;charset&#039;];
$this-&gt;baseTemplateClass = $options[&#039;base_template_class&#039;];
$this-&gt;autoReload = null === $options[&#039;auto_reload&#039;] ? $this-&gt;debug : (bool) $options[&#039;auto_reload&#039;];
$this-&gt;strictVariables = (bool) $options[&#039;strict_variables&#039;];
$this-&gt;runtimeInitialized = false;
$this-&gt;setCache($options[&#039;cache&#039;]);
$this-&gt;functionCallbacks = array();
$this-&gt;filterCallbacks = array();
$this-&gt;addExtension(new Twig_Extension_Core());
$this-&gt;addExtension(new Twig_Extension_Escaper($options[&#039;autoescape&#039;]));
$this-&gt;addExtension(new Twig_Extension_Optimizer($options[&#039;optimizations&#039;]));
$this-&gt;extensionInitialized = false;
$this-&gt;staging = new Twig_Extension_Staging();
}
public function getBaseTemplateClass()
{
return $this-&gt;baseTemplateClass;
}
public function setBaseTemplateClass($class)
{
$this-&gt;baseTemplateClass = $class;
}
public function enableDebug()
{
$this-&gt;debug = true;
}
public function disableDebug()
{
$this-&gt;debug = false;
}
public function isDebug()
{
return $this-&gt;debug;
}
public function enableAutoReload()
{
$this-&gt;autoReload = true;
}
public function disableAutoReload()
{
$this-&gt;autoReload = false;
}
public function isAutoReload()
{
return $this-&gt;autoReload;
}
public function enableStrictVariables()
{
$this-&gt;strictVariables = true;
}
public function disableStrictVariables()
{
$this-&gt;strictVariables = false;
}
public function isStrictVariables()
{
return $this-&gt;strictVariables;
}
public function getCache()
{
return $this-&gt;cache;
}
public function setCache($cache)
{
$this-&gt;cache = $cache ? $cache : false;
}
public function getCacheFilename($name)
{
if (false === $this-&gt;cache) {
return false;
}
$class = substr($this-&gt;getTemplateClass($name), strlen($this-&gt;templateClassPrefix));
return $this-&gt;getCache().&#039;/&#039;.substr($class, 0, 2).&#039;/&#039;.substr($class, 2, 2).&#039;/&#039;.substr($class, 4).&#039;.php&#039;;
}
public function getTemplateClass($name, $index = null)
{
return $this-&gt;templateClassPrefix.md5($this-&gt;getLoader()-&gt;getCacheKey($name)).(null === $index ?&#039;&#039;:&#039;_&#039;.$index);
}
public function getTemplateClassPrefix()
{
return $this-&gt;templateClassPrefix;
}
public function render($name, array $context = array())
{
return $this-&gt;loadTemplate($name)-&gt;render($context);
}
public function display($name, array $context = array())
{
$this-&gt;loadTemplate($name)-&gt;display($context);
}
public function loadTemplate($name, $index = null)
{
$cls = $this-&gt;getTemplateClass($name, $index);
if (isset($this-&gt;loadedTemplates[$cls])) {
return $this-&gt;loadedTemplates[$cls];
}
if (!class_exists($cls, false)) {
if (false === $cache = $this-&gt;getCacheFilename($name)) {
eval(&#039;?&gt;&#039;.$this-&gt;compileSource($this-&gt;getLoader()-&gt;getSource($name), $name));
} else {
if (!is_file($cache) || ($this-&gt;isAutoReload() &amp;&amp; !$this-&gt;isTemplateFresh($name, filemtime($cache)))) {
$this-&gt;writeCacheFile($cache, $this-&gt;compileSource($this-&gt;getLoader()-&gt;getSource($name), $name));
}
require_once $cache;
}
}
if (!$this-&gt;runtimeInitialized) {
$this-&gt;initRuntime();
}
return $this-&gt;loadedTemplates[$cls] = new $cls($this);
}
public function isTemplateFresh($name, $time)
{
foreach ($this-&gt;extensions as $extension) {
$r = new ReflectionObject($extension);
if (filemtime($r-&gt;getFileName()) &gt; $time) {
return false;
}
}
return $this-&gt;getLoader()-&gt;isFresh($name, $time);
}
public function resolveTemplate($names)
{
if (!is_array($names)) {
$names = array($names);
}
foreach ($names as $name) {
if ($name instanceof Twig_Template) {
return $name;
}
try {
return $this-&gt;loadTemplate($name);
} catch (Twig_Error_Loader $e) {
}
}
if (1 === count($names)) {
throw $e;
}
throw new Twig_Error_Loader(sprintf(&#039;Unable to find one of the following templates: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, $names)));
}
public function clearTemplateCache()
{
$this-&gt;loadedTemplates = array();
}
public function clearCacheFiles()
{
if (false === $this-&gt;cache) {
return;
}
foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this-&gt;cache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
if ($file-&gt;isFile()) {
@unlink($file-&gt;getPathname());
}
}
}
public function getLexer()
{
if (null === $this-&gt;lexer) {
$this-&gt;lexer = new Twig_Lexer($this);
}
return $this-&gt;lexer;
}
public function setLexer(Twig_LexerInterface $lexer)
{
$this-&gt;lexer = $lexer;
}
public function tokenize($source, $name = null)
{
return $this-&gt;getLexer()-&gt;tokenize($source, $name);
}
public function getParser()
{
if (null === $this-&gt;parser) {
$this-&gt;parser = new Twig_Parser($this);
}
return $this-&gt;parser;
}
public function setParser(Twig_ParserInterface $parser)
{
$this-&gt;parser = $parser;
}
public function parse(Twig_TokenStream $tokens)
{
return $this-&gt;getParser()-&gt;parse($tokens);
}
public function getCompiler()
{
if (null === $this-&gt;compiler) {
$this-&gt;compiler = new Twig_Compiler($this);
}
return $this-&gt;compiler;
}
public function setCompiler(Twig_CompilerInterface $compiler)
{
$this-&gt;compiler = $compiler;
}
public function compile(Twig_NodeInterface $node)
{
return $this-&gt;getCompiler()-&gt;compile($node)-&gt;getSource();
}
public function compileSource($source, $name = null)
{
try {
return $this-&gt;compile($this-&gt;parse($this-&gt;tokenize($source, $name)));
} catch (Twig_Error $e) {
$e-&gt;setTemplateFile($name);
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the compilation of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $name, $e);
}
}
public function setLoader(Twig_LoaderInterface $loader)
{
$this-&gt;loader = $loader;
}
public function getLoader()
{
if (null === $this-&gt;loader) {
throw new LogicException(&#039;You must set a loader first.&#039;);
}
return $this-&gt;loader;
}
public function setCharset($charset)
{
$this-&gt;charset = $charset;
}
public function getCharset()
{
return $this-&gt;charset;
}
public function initRuntime()
{
$this-&gt;runtimeInitialized = true;
foreach ($this-&gt;getExtensions() as $extension) {
$extension-&gt;initRuntime($this);
}
}
public function hasExtension($name)
{
return isset($this-&gt;extensions[$name]);
}
public function getExtension($name)
{
if (!isset($this-&gt;extensions[$name])) {
throw new Twig_Error_Runtime(sprintf(&#039;The &quot;%s&quot; extension is not enabled.&#039;, $name));
}
return $this-&gt;extensions[$name];
}
public function addExtension(Twig_ExtensionInterface $extension)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to register extension &quot;%s&quot; as extensions have already been initialized.&#039;, $extension-&gt;getName()));
}
$this-&gt;extensions[$extension-&gt;getName()] = $extension;
}
public function removeExtension($name)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to remove extension &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
unset($this-&gt;extensions[$name]);
}
public function setExtensions(array $extensions)
{
foreach ($extensions as $extension) {
$this-&gt;addExtension($extension);
}
}
public function getExtensions()
{
return $this-&gt;extensions;
}
public function addTokenParser(Twig_TokenParserInterface $parser)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a token parser as extensions have already been initialized.&#039;);
}
$this-&gt;staging-&gt;addTokenParser($parser);
}
public function getTokenParsers()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;parsers;
}
public function getTags()
{
$tags = array();
foreach ($this-&gt;getTokenParsers()-&gt;getParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$tags[$parser-&gt;getTag()] = $parser;
}
}
return $tags;
}
public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a node visitor as extensions have already been initialized.&#039;, $extension-&gt;getName());
}
$this-&gt;staging-&gt;addNodeVisitor($visitor);
}
public function getNodeVisitors()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;visitors;
}
public function addFilter($name, $filter = null)
{
if (!$name instanceof Twig_SimpleFilter &amp;&amp; !($filter instanceof Twig_SimpleFilter || $filter instanceof Twig_FilterInterface)) {
throw new LogicException(&#039;A filter must be an instance of Twig_FilterInterface or Twig_SimpleFilter&#039;);
}
if ($name instanceof Twig_SimpleFilter) {
$filter = $name;
$name = $filter-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add filter &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFilter($name, $filter);
}
public function getFilter($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;filters[$name])) {
return $this-&gt;filters[$name];
}
foreach ($this-&gt;filters as $pattern =&gt; $filter) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$filter-&gt;setArguments($matches);
return $filter;
}
}
}
foreach ($this-&gt;filterCallbacks as $callback) {
if (false !== $filter = call_user_func($callback, $name)) {
return $filter;
}
}
return false;
}
public function registerUndefinedFilterCallback($callable)
{
$this-&gt;filterCallbacks[] = $callable;
}
public function getFilters()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;filters;
}
public function addTest($name, $test = null)
{
if (!$name instanceof Twig_SimpleTest &amp;&amp; !($test instanceof Twig_SimpleTest || $test instanceof Twig_TestInterface)) {
throw new LogicException(&#039;A test must be an instance of Twig_TestInterface or Twig_SimpleTest&#039;);
}
if ($name instanceof Twig_SimpleTest) {
$test = $name;
$name = $test-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add test &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addTest($name, $test);
}
public function getTests()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;tests;
}
public function getTest($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;tests[$name])) {
return $this-&gt;tests[$name];
}
return false;
}
public function addFunction($name, $function = null)
{
if (!$name instanceof Twig_SimpleFunction &amp;&amp; !($function instanceof Twig_SimpleFunction || $function instanceof Twig_FunctionInterface)) {
throw new LogicException(&#039;A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction&#039;);
}
if ($name instanceof Twig_SimpleFunction) {
$function = $name;
$name = $function-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add function &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFunction($name, $function);
}
public function getFunction($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;functions[$name])) {
return $this-&gt;functions[$name];
}
foreach ($this-&gt;functions as $pattern =&gt; $function) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$function-&gt;setArguments($matches);
return $function;
}
}
}
foreach ($this-&gt;functionCallbacks as $callback) {
if (false !== $function = call_user_func($callback, $name)) {
return $function;
}
}
return false;
}
public function registerUndefinedFunctionCallback($callable)
{
$this-&gt;functionCallbacks[] = $callable;
}
public function getFunctions()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;functions;
}
public function addGlobal($name, $value)
{
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
}
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
$this-&gt;globals[$name] = $value;
} else {
$this-&gt;staging-&gt;addGlobal($name, $value);
}
}
public function getGlobals()
{
if (!$this-&gt;runtimeInitialized &amp;&amp; !$this-&gt;extensionInitialized) {
return $this-&gt;initGlobals();
}
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
return $this-&gt;globals;
}
public function mergeGlobals(array $context)
{
foreach ($this-&gt;getGlobals() as $key =&gt; $value) {
if (!array_key_exists($key, $context)) {
$context[$key] = $value;
}
}
return $context;
}
public function getUnaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;unaryOperators;
}
public function getBinaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;binaryOperators;
}
public function computeAlternatives($name, $items)
{
$alternatives = array();
foreach ($items as $item) {
$lev = levenshtein($name, $item);
if ($lev &lt;= strlen($name) / 3 || false !== strpos($item, $name)) {
$alternatives[$item] = $lev;
}
}
asort($alternatives);
return array_keys($alternatives);
}
protected function initGlobals()
{
$globals = array();
foreach ($this-&gt;extensions as $extension) {
$extGlob = $extension-&gt;getGlobals();
if (!is_array($extGlob)) {
throw new UnexpectedValueException(sprintf(&#039;&quot;%s::getGlobals()&quot; must return an array of globals.&#039;, get_class($extension)));
}
$globals[] = $extGlob;
}
$globals[] = $this-&gt;staging-&gt;getGlobals();
return call_user_func_array(&#039;array_merge&#039;, $globals);
}
protected function initExtensions()
{
if ($this-&gt;extensionInitialized) {
return;
}
$this-&gt;extensionInitialized = true;
$this-&gt;parsers = new Twig_TokenParserBroker();
$this-&gt;filters = array();
$this-&gt;functions = array();
$this-&gt;tests = array();
$this-&gt;visitors = array();
$this-&gt;unaryOperators = array();
$this-&gt;binaryOperators = array();
foreach ($this-&gt;extensions as $extension) {
$this-&gt;initExtension($extension);
}
$this-&gt;initExtension($this-&gt;staging);
}
protected function initExtension(Twig_ExtensionInterface $extension)
{
foreach ($extension-&gt;getFilters() as $name =&gt; $filter) {
if ($name instanceof Twig_SimpleFilter) {
$filter = $name;
$name = $filter-&gt;getName();
} elseif ($filter instanceof Twig_SimpleFilter) {
$name = $filter-&gt;getName();
}
$this-&gt;filters[$name] = $filter;
}
foreach ($extension-&gt;getFunctions() as $name =&gt; $function) {
if ($name instanceof Twig_SimpleFunction) {
$function = $name;
$name = $function-&gt;getName();
} elseif ($function instanceof Twig_SimpleFunction) {
$name = $function-&gt;getName();
}
$this-&gt;functions[$name] = $function;
}
foreach ($extension-&gt;getTests() as $name =&gt; $test) {
if ($name instanceof Twig_SimpleTest) {
$test = $name;
$name = $test-&gt;getName();
} elseif ($test instanceof Twig_SimpleTest) {
$name = $test-&gt;getName();
}
$this-&gt;tests[$name] = $test;
}
foreach ($extension-&gt;getTokenParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$this-&gt;parsers-&gt;addTokenParser($parser);
} elseif ($parser instanceof Twig_TokenParserBrokerInterface) {
$this-&gt;parsers-&gt;addTokenParserBroker($parser);
} else {
throw new LogicException(&#039;getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances&#039;);
}
}
foreach ($extension-&gt;getNodeVisitors() as $visitor) {
$this-&gt;visitors[] = $visitor;
}
if ($operators = $extension-&gt;getOperators()) {
if (2 !== count($operators)) {
throw new InvalidArgumentException(sprintf(&#039;&quot;%s::getOperators()&quot; does not return a valid operators array.&#039;, get_class($extension)));
}
$this-&gt;unaryOperators = array_merge($this-&gt;unaryOperators, $operators[0]);
$this-&gt;binaryOperators = array_merge($this-&gt;binaryOperators, $operators[1]);
}
}
protected function writeCacheFile($file, $content)
{
$dir = dirname($file);
if (!is_dir($dir)) {
if (false === @mkdir($dir, 0777, true) &amp;&amp; !is_dir($dir)) {
throw new RuntimeException(sprintf(&quot;Unable to create the cache directory (%s).&quot;, $dir));
}
} elseif (!is_writable($dir)) {
throw new RuntimeException(sprintf(&quot;Unable to write in the cache directory (%s).&quot;, $dir));
}
$tmpFile = tempnam(dirname($file), basename($file));
if (false !== @file_put_contents($tmpFile, $content)) {
if (@rename($tmpFile, $file) || (@copy($tmpFile, $file) &amp;&amp; unlink($tmpFile))) {
@chmod($file, 0666 &amp; ~umask());
return;
}
}
throw new RuntimeException(sprintf(&#039;Failed to write cache file &quot;%s&quot;.&#039;, $file));
}
}
}
namespace
{
interface Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment);
public function getTokenParsers();
public function getNodeVisitors();
public function getFilters();
public function getTests();
public function getFunctions();
public function getOperators();
public function getGlobals();
public function getName();
}
}
namespace
{
abstract class Twig_Extension implements Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment)
{
}
public function getTokenParsers()
{
return array();
}
public function getNodeVisitors()
{
return array();
}
public function getFilters()
{
return array();
}
public function getTests()
{
return array();
}
public function getFunctions()
{
return array();
}
public function getOperators()
{
return array();
}
public function getGlobals()
{
return array();
}
}
}
namespace
{
if (!defined(&#039;ENT_SUBSTITUTE&#039;)) {
define(&#039;ENT_SUBSTITUTE&#039;, 8);
}
class Twig_Extension_Core extends Twig_Extension
{
protected $dateFormats = array(&#039;F j, Y H:i&#039;,&#039;%d days&#039;);
protected $numberFormat = array(0,&#039;.&#039;,&#039;,&#039;);
protected $timezone = null;
public function setDateFormat($format = null, $dateIntervalFormat = null)
{
if (null !== $format) {
$this-&gt;dateFormats[0] = $format;
}
if (null !== $dateIntervalFormat) {
$this-&gt;dateFormats[1] = $dateIntervalFormat;
}
}
public function getDateFormat()
{
return $this-&gt;dateFormats;
}
public function setTimezone($timezone)
{
$this-&gt;timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);
}
public function getTimezone()
{
if (null === $this-&gt;timezone) {
$this-&gt;timezone = new DateTimeZone(date_default_timezone_get());
}
return $this-&gt;timezone;
}
public function setNumberFormat($decimal, $decimalPoint, $thousandSep)
{
$this-&gt;numberFormat = array($decimal, $decimalPoint, $thousandSep);
}
public function getNumberFormat()
{
return $this-&gt;numberFormat;
}
public function getTokenParsers()
{
return array(
new Twig_TokenParser_For(),
new Twig_TokenParser_If(),
new Twig_TokenParser_Extends(),
new Twig_TokenParser_Include(),
new Twig_TokenParser_Block(),
new Twig_TokenParser_Use(),
new Twig_TokenParser_Filter(),
new Twig_TokenParser_Macro(),
new Twig_TokenParser_Import(),
new Twig_TokenParser_From(),
new Twig_TokenParser_Set(),
new Twig_TokenParser_Spaceless(),
new Twig_TokenParser_Flush(),
new Twig_TokenParser_Do(),
new Twig_TokenParser_Embed(),
);
}
public function getFilters()
{
$filters = array(
new Twig_SimpleFilter(&#039;date&#039;,&#039;twig_date_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;date_modify&#039;,&#039;twig_date_modify_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;format&#039;,&#039;sprintf&#039;),
new Twig_SimpleFilter(&#039;replace&#039;,&#039;strtr&#039;),
new Twig_SimpleFilter(&#039;number_format&#039;,&#039;twig_number_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;abs&#039;,&#039;abs&#039;),
new Twig_SimpleFilter(&#039;url_encode&#039;,&#039;twig_urlencode_filter&#039;),
new Twig_SimpleFilter(&#039;json_encode&#039;,&#039;twig_jsonencode_filter&#039;),
new Twig_SimpleFilter(&#039;convert_encoding&#039;,&#039;twig_convert_encoding&#039;),
new Twig_SimpleFilter(&#039;title&#039;,&#039;twig_title_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;capitalize&#039;,&#039;twig_capitalize_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;upper&#039;,&#039;strtoupper&#039;),
new Twig_SimpleFilter(&#039;lower&#039;,&#039;strtolower&#039;),
new Twig_SimpleFilter(&#039;striptags&#039;,&#039;strip_tags&#039;),
new Twig_SimpleFilter(&#039;trim&#039;,&#039;trim&#039;),
new Twig_SimpleFilter(&#039;nl2br&#039;,&#039;nl2br&#039;, array(&#039;pre_escape&#039;=&gt;&#039;html&#039;,&#039;is_safe&#039;=&gt; array(&#039;html&#039;))),
new Twig_SimpleFilter(&#039;join&#039;,&#039;twig_join_filter&#039;),
new Twig_SimpleFilter(&#039;split&#039;,&#039;twig_split_filter&#039;),
new Twig_SimpleFilter(&#039;sort&#039;,&#039;twig_sort_filter&#039;),
new Twig_SimpleFilter(&#039;merge&#039;,&#039;twig_array_merge&#039;),
new Twig_SimpleFilter(&#039;batch&#039;,&#039;twig_array_batch&#039;),
new Twig_SimpleFilter(&#039;reverse&#039;,&#039;twig_reverse_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;length&#039;,&#039;twig_length_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;slice&#039;,&#039;twig_slice&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;first&#039;,&#039;twig_first&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;last&#039;,&#039;twig_last&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;default&#039;,&#039;_twig_default_filter&#039;, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Filter_Default&#039;)),
new Twig_SimpleFilter(&#039;keys&#039;,&#039;twig_get_array_keys_filter&#039;),
new Twig_SimpleFilter(&#039;escape&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
new Twig_SimpleFilter(&#039;e&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
);
if (function_exists(&#039;mb_get_info&#039;)) {
$filters[] = new Twig_SimpleFilter(&#039;upper&#039;,&#039;twig_upper_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
$filters[] = new Twig_SimpleFilter(&#039;lower&#039;,&#039;twig_lower_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
}
return $filters;
}
public function getFunctions()
{
return array(
new Twig_SimpleFunction(&#039;range&#039;,&#039;range&#039;),
new Twig_SimpleFunction(&#039;constant&#039;,&#039;twig_constant&#039;),
new Twig_SimpleFunction(&#039;cycle&#039;,&#039;twig_cycle&#039;),
new Twig_SimpleFunction(&#039;random&#039;,&#039;twig_random&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;date&#039;,&#039;twig_date_converter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;include&#039;,&#039;twig_include&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;needs_context&#039;=&gt; true)),
);
}
public function getTests()
{
return array(
new Twig_SimpleTest(&#039;even&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Even&#039;)),
new Twig_SimpleTest(&#039;odd&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Odd&#039;)),
new Twig_SimpleTest(&#039;defined&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Defined&#039;)),
new Twig_SimpleTest(&#039;sameas&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Sameas&#039;)),
new Twig_SimpleTest(&#039;none&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;null&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;divisibleby&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Divisibleby&#039;)),
new Twig_SimpleTest(&#039;constant&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Constant&#039;)),
new Twig_SimpleTest(&#039;empty&#039;,&#039;twig_test_empty&#039;),
new Twig_SimpleTest(&#039;iterable&#039;,&#039;twig_test_iterable&#039;),
);
}
public function getOperators()
{
return array(
array(&#039;not&#039;=&gt; array(&#039;precedence&#039;=&gt; 50,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Not&#039;),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Neg&#039;),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Pos&#039;),
),
array(&#039;or&#039;=&gt; array(&#039;precedence&#039;=&gt; 10,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Or&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;and&#039;=&gt; array(&#039;precedence&#039;=&gt; 15,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_And&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-or&#039;=&gt; array(&#039;precedence&#039;=&gt; 16,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseOr&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-xor&#039;=&gt; array(&#039;precedence&#039;=&gt; 17,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseXor&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-and&#039;=&gt; array(&#039;precedence&#039;=&gt; 18,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseAnd&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;==&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Equal&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;!=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Less&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Greater&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_GreaterEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_LessEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;not in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotIn&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_In&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;..&#039;=&gt; array(&#039;precedence&#039;=&gt; 25,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Range&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Add&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Sub&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;~&#039;=&gt; array(&#039;precedence&#039;=&gt; 40,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Concat&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;*&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mul&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;/&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Div&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;//&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_FloorDiv&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;%&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mod&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is not&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseNotTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;**&#039;=&gt; array(&#039;precedence&#039;=&gt; 200,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Power&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_RIGHT),
),
);
}
public function parseNotTestExpression(Twig_Parser $parser, $node)
{
return new Twig_Node_Expression_Unary_Not($this-&gt;parseTestExpression($parser, $node), $parser-&gt;getCurrentToken()-&gt;getLine());
}
public function parseTestExpression(Twig_Parser $parser, $node)
{
$stream = $parser-&gt;getStream();
$name = $stream-&gt;expect(Twig_Token::NAME_TYPE)-&gt;getValue();
$arguments = null;
if ($stream-&gt;test(Twig_Token::PUNCTUATION_TYPE,&#039;(&#039;)) {
$arguments = $parser-&gt;getExpressionParser()-&gt;parseArguments(true);
}
$class = $this-&gt;getTestNodeClass($parser, $name, $node-&gt;getLine());
return new $class($node, $name, $arguments, $parser-&gt;getCurrentToken()-&gt;getLine());
}
protected function getTestNodeClass(Twig_Parser $parser, $name, $line)
{
$env = $parser-&gt;getEnvironment();
$testMap = $env-&gt;getTests();
if (!isset($testMap[$name])) {
$message = sprintf(&#039;The test &quot;%s&quot; does not exist&#039;, $name);
if ($alternatives = $env-&gt;computeAlternatives($name, array_keys($env-&gt;getTests()))) {
$message = sprintf(&#039;%s. Did you mean &quot;%s&quot;&#039;, $message, implode(&#039;&quot;, &quot;&#039;, $alternatives));
}
throw new Twig_Error_Syntax($message, $line, $parser-&gt;getFilename());
}
if ($testMap[$name] instanceof Twig_SimpleTest) {
return $testMap[$name]-&gt;getNodeClass();
}
return $testMap[$name] instanceof Twig_Test_Node ? $testMap[$name]-&gt;getClass() :&#039;Twig_Node_Expression_Test&#039;;
}
public function getName()
{
return&#039;core&#039;;
}
}
function twig_cycle($values, $position)
{
if (!is_array($values) &amp;&amp; !$values instanceof ArrayAccess) {
return $values;
}
return $values[$position % count($values)];
}
function twig_random(Twig_Environment $env, $values = null)
{
if (null === $values) {
return mt_rand();
}
if (is_int($values) || is_float($values)) {
return $values &lt; 0 ? mt_rand($values, 0) : mt_rand(0, $values);
}
if ($values instanceof Traversable) {
$values = iterator_to_array($values);
} elseif (is_string($values)) {
if (&#039;&#039;=== $values) {
return&#039;&#039;;
}
if (null !== $charset = $env-&gt;getCharset()) {
if (&#039;UTF-8&#039;!= $charset) {
$values = twig_convert_encoding($values,&#039;UTF-8&#039;, $charset);
}
$values = preg_split(&#039;/(?&lt;!^)(?!$)/u&#039;, $values);
if (&#039;UTF-8&#039;!= $charset) {
foreach ($values as $i =&gt; $value) {
$values[$i] = twig_convert_encoding($value, $charset,&#039;UTF-8&#039;);
}
}
} else {
return $values[mt_rand(0, strlen($values) - 1)];
}
}
if (!is_array($values)) {
return $values;
}
if (0 === count($values)) {
throw new Twig_Error_Runtime(&#039;The random function cannot pick from an empty array.&#039;);
}
return $values[array_rand($values, 1)];
}
function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null)
{
if (null === $format) {
$formats = $env-&gt;getExtension(&#039;core&#039;)-&gt;getDateFormat();
$format = $date instanceof DateInterval ? $formats[1] : $formats[0];
}
if ($date instanceof DateInterval) {
return $date-&gt;format($format);
}
return twig_date_converter($env, $date, $timezone)-&gt;format($format);
}
function twig_date_modify_filter(Twig_Environment $env, $date, $modifier)
{
$date = twig_date_converter($env, $date, false);
$date-&gt;modify($modifier);
return $date;
}
function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null)
{
if (!$timezone) {
$defaultTimezone = $env-&gt;getExtension(&#039;core&#039;)-&gt;getTimezone();
} elseif (!$timezone instanceof DateTimeZone) {
$defaultTimezone = new DateTimeZone($timezone);
} else {
$defaultTimezone = $timezone;
}
if ($date instanceof DateTime) {
$date = clone $date;
if (false !== $timezone) {
$date-&gt;setTimezone($defaultTimezone);
}
return $date;
}
$asString = (string) $date;
if (ctype_digit($asString) || (!empty($asString) &amp;&amp;&#039;-&#039;=== $asString[0] &amp;&amp; ctype_digit(substr($asString, 1)))) {
$date =&#039;@&#039;.$date;
}
$date = new DateTime($date, $defaultTimezone);
if (false !== $timezone) {
$date-&gt;setTimezone($defaultTimezone);
}
return $date;
}
function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)
{
$defaults = $env-&gt;getExtension(&#039;core&#039;)-&gt;getNumberFormat();
if (null === $decimal) {
$decimal = $defaults[0];
}
if (null === $decimalPoint) {
$decimalPoint = $defaults[1];
}
if (null === $thousandSep) {
$thousandSep = $defaults[2];
}
return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);
}
function twig_urlencode_filter($url, $raw = false)
{
if (is_array($url)) {
return http_build_query($url,&#039;&#039;,&#039;&amp;&#039;);
}
if ($raw) {
return rawurlencode($url);
}
return urlencode($url);
}
if (version_compare(PHP_VERSION,&#039;5.3.0&#039;,&#039;&lt;&#039;)) {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value);
}
} else {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value, $options);
}
}
function _twig_markup2string(&amp;$value)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
}
}
function twig_array_merge($arr1, $arr2)
{
if (!is_array($arr1) || !is_array($arr2)) {
throw new Twig_Error_Runtime(&#039;The merge filter only works with arrays or hashes.&#039;);
}
return array_merge($arr1, $arr2);
}
function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false)
{
if ($item instanceof Traversable) {
$item = iterator_to_array($item, false);
}
if (is_array($item)) {
return array_slice($item, $start, $length, $preserveKeys);
}
$item = (string) $item;
if (function_exists(&#039;mb_get_info&#039;) &amp;&amp; null !== $charset = $env-&gt;getCharset()) {
return mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset);
}
return null === $length ? substr($item, $start) : substr($item, $start, $length);
}
function twig_first(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, 0, 1, false);
return is_string($elements) ? $elements[0] : current($elements);
}
function twig_last(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, -1, 1, false);
return is_string($elements) ? $elements[0] : current($elements);
}
function twig_join_filter($value, $glue =&#039;&#039;)
{
if ($value instanceof Traversable) {
$value = iterator_to_array($value, false);
}
return implode($glue, (array) $value);
}
function twig_split_filter($value, $delimiter, $limit = null)
{
if (empty($delimiter)) {
return str_split($value, null === $limit ? 1 : $limit);
}
return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);
}
function _twig_default_filter($value, $default =&#039;&#039;)
{
if (twig_test_empty($value)) {
return $default;
}
return $value;
}
function twig_get_array_keys_filter($array)
{
if (is_object($array) &amp;&amp; $array instanceof Traversable) {
return array_keys(iterator_to_array($array));
}
if (!is_array($array)) {
return array();
}
return array_keys($array);
}
function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false)
{
if (is_object($item) &amp;&amp; $item instanceof Traversable) {
return array_reverse(iterator_to_array($item), $preserveKeys);
}
if (is_array($item)) {
return array_reverse($item, $preserveKeys);
}
if (null !== $charset = $env-&gt;getCharset()) {
$string = (string) $item;
if (&#039;UTF-8&#039;!= $charset) {
$item = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
preg_match_all(&#039;/./us&#039;, $item, $matches);
$string = implode(&#039;&#039;, array_reverse($matches[0]));
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
}
return strrev((string) $item);
}
function twig_sort_filter($array)
{
asort($array);
return $array;
}
function twig_in_filter($value, $compare)
{
if (is_array($compare)) {
return in_array($value, $compare, is_object($value));
} elseif (is_string($compare)) {
if (!strlen($value)) {
return empty($compare);
}
return false !== strpos($compare, (string) $value);
} elseif ($compare instanceof Traversable) {
return in_array($value, iterator_to_array($compare, false), is_object($value));
}
return false;
}
function twig_escape_filter(Twig_Environment $env, $string, $strategy =&#039;html&#039;, $charset = null, $autoescape = false)
{
if ($autoescape &amp;&amp; is_object($string) &amp;&amp; $string instanceof Twig_Markup) {
return $string;
}
if (!is_string($string) &amp;&amp; !(is_object($string) &amp;&amp; method_exists($string,&#039;__toString&#039;))) {
return $string;
}
if (null === $charset) {
$charset = $env-&gt;getCharset();
}
$string = (string) $string;
switch ($strategy) {
case&#039;js&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\._]#Su&#039;,&#039;_twig_escape_js_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;css&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9]#Su&#039;,&#039;_twig_escape_css_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;html_attr&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\.\-_]#Su&#039;,&#039;_twig_escape_html_attr_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;html&#039;:
static $htmlspecialcharsCharsets = array(&#039;iso-8859-1&#039;=&gt; true,&#039;iso8859-1&#039;=&gt; true,&#039;iso-8859-15&#039;=&gt; true,&#039;iso8859-15&#039;=&gt; true,&#039;utf-8&#039;=&gt; true,&#039;cp866&#039;=&gt; true,&#039;ibm866&#039;=&gt; true,&#039;866&#039;=&gt; true,&#039;cp1251&#039;=&gt; true,&#039;windows-1251&#039;=&gt; true,&#039;win-1251&#039;=&gt; true,&#039;1251&#039;=&gt; true,&#039;cp1252&#039;=&gt; true,&#039;windows-1252&#039;=&gt; true,&#039;1252&#039;=&gt; true,&#039;koi8-r&#039;=&gt; true,&#039;koi8-ru&#039;=&gt; true,&#039;koi8r&#039;=&gt; true,&#039;big5&#039;=&gt; true,&#039;950&#039;=&gt; true,&#039;gb2312&#039;=&gt; true,&#039;936&#039;=&gt; true,&#039;big5-hkscs&#039;=&gt; true,&#039;shift_jis&#039;=&gt; true,&#039;sjis&#039;=&gt; true,&#039;932&#039;=&gt; true,&#039;euc-jp&#039;=&gt; true,&#039;eucjp&#039;=&gt; true,&#039;iso8859-5&#039;=&gt; true,&#039;iso-8859-5&#039;=&gt; true,&#039;macroman&#039;=&gt; true,
);
if (isset($htmlspecialcharsCharsets[strtolower($charset)])) {
return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
}
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
$string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE,&#039;UTF-8&#039;);
return twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
case&#039;url&#039;:
if (version_compare(PHP_VERSION,&#039;5.3.0&#039;,&#039;&lt;&#039;)) {
return str_replace(&#039;%7E&#039;,&#039;~&#039;, rawurlencode($string));
}
return rawurlencode($string);
default:
throw new Twig_Error_Runtime(sprintf(&#039;Invalid escaping strategy &quot;%s&quot; (valid ones: html, js, url, css, and html_attr).&#039;, $strategy));
}
}
function twig_escape_filter_is_safe(Twig_Node $filterArgs)
{
foreach ($filterArgs as $arg) {
if ($arg instanceof Twig_Node_Expression_Constant) {
return array($arg-&gt;getAttribute(&#039;value&#039;));
}
return array();
}
return array(&#039;html&#039;);
}
if (function_exists(&#039;mb_convert_encoding&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return mb_convert_encoding($string, $to, $from);
}
} elseif (function_exists(&#039;iconv&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return iconv($from, $to, $string);
}
} else {
function twig_convert_encoding($string, $to, $from)
{
throw new Twig_Error_Runtime(&#039;No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).&#039;);
}
}
function _twig_escape_js_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
return&#039;\\x&#039;.strtoupper(substr(&#039;00&#039;.bin2hex($char), -2));
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\u&#039;.strtoupper(substr(&#039;0000&#039;.bin2hex($char), -4));
}
function _twig_escape_css_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
$hex = ltrim(strtoupper(bin2hex($char)),&#039;0&#039;);
if (0 === strlen($hex)) {
$hex =&#039;0&#039;;
}
return&#039;\\&#039;.$hex.&#039; &#039;;
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\&#039;.ltrim(strtoupper(bin2hex($char)),&#039;0&#039;).&#039; &#039;;
}
function _twig_escape_html_attr_callback($matches)
{
static $entityMap = array(
34 =&gt;&#039;quot&#039;,
38 =&gt;&#039;amp&#039;,
60 =&gt;&#039;lt&#039;,
62 =&gt;&#039;gt&#039;,
);
$chr = $matches[0];
$ord = ord($chr);
if (($ord &lt;= 0x1f &amp;&amp; $chr !=&quot;\t&quot;&amp;&amp; $chr !=&quot;\n&quot;&amp;&amp; $chr !=&quot;\r&quot;) || ($ord &gt;= 0x7f &amp;&amp; $ord &lt;= 0x9f)) {
return&#039;&amp;#xFFFD;&#039;;
}
if (strlen($chr) == 1) {
$hex = strtoupper(substr(&#039;00&#039;.bin2hex($chr), -2));
} else {
$chr = twig_convert_encoding($chr,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
$hex = strtoupper(substr(&#039;0000&#039;.bin2hex($chr), -4));
}
$int = hexdec($hex);
if (array_key_exists($int, $entityMap)) {
return sprintf(&#039;&amp;%s;&#039;, $entityMap[$int]);
}
return sprintf(&#039;&amp;#x%s;&#039;, $hex);
}
if (function_exists(&#039;mb_get_info&#039;)) {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? mb_strlen($thing, $env-&gt;getCharset()) : count($thing);
}
function twig_upper_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtoupper($string, $charset);
}
return strtoupper($string);
}
function twig_lower_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtolower($string, $charset);
}
return strtolower($string);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_convert_case($string, MB_CASE_TITLE, $charset);
}
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset).
mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset);
}
return ucfirst(strtolower($string));
}
}
else {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? strlen($thing) : count($thing);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
return ucfirst(strtolower($string));
}
}
function twig_ensure_traversable($seq)
{
if ($seq instanceof Traversable || is_array($seq)) {
return $seq;
}
return array();
}
function twig_test_empty($value)
{
if ($value instanceof Countable) {
return 0 == count($value);
}
return&#039;&#039;=== $value || false === $value || null === $value || array() === $value;
}
function twig_test_iterable($value)
{
return $value instanceof Traversable || is_array($value);
}
function twig_include(Twig_Environment $env, $context, $template, $variables = array(), $withContext = true, $ignoreMissing = false, $sandboxed = false)
{
if ($withContext) {
$variables = array_merge($context, $variables);
}
if ($isSandboxed = $sandboxed &amp;&amp; $env-&gt;hasExtension(&#039;sandbox&#039;)) {
$sandbox = $env-&gt;getExtension(&#039;sandbox&#039;);
if (!$alreadySandboxed = $sandbox-&gt;isSandboxed()) {
$sandbox-&gt;enableSandbox();
}
}
try {
return $env-&gt;resolveTemplate($template)-&gt;display($variables);
} catch (Twig_Error_Loader $e) {
if (!$ignoreMissing) {
throw $e;
}
}
if ($isSandboxed &amp;&amp; !$alreadySandboxed) {
$sandbox-&gt;disableSandbox();
}
}
function twig_constant($constant, $object = null)
{
if (null !== $object) {
$constant = get_class($object).&#039;::&#039;.$constant;
}
return constant($constant);
}
function twig_array_batch($items, $size, $fill = null)
{
if ($items instanceof Traversable) {
$items = iterator_to_array($items, false);
}
$size = ceil($size);
$result = array_chunk($items, $size, true);
if (null !== $fill) {
$last = count($result) - 1;
$result[$last] = array_merge(
$result[$last],
array_fill(0, $size - count($result[$last]), $fill)
);
}
return $result;
}
}
namespace
{
class Twig_Extension_Escaper extends Twig_Extension
{
protected $defaultStrategy;
public function __construct($defaultStrategy =&#039;html&#039;)
{
$this-&gt;setDefaultStrategy($defaultStrategy);
}
public function getTokenParsers()
{
return array(new Twig_TokenParser_AutoEscape());
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Escaper());
}
public function getFilters()
{
return array(
new Twig_SimpleFilter(&#039;raw&#039;,&#039;twig_raw_filter&#039;, array(&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
);
}
public function setDefaultStrategy($defaultStrategy)
{
if (true === $defaultStrategy) {
$defaultStrategy =&#039;html&#039;;
}
$this-&gt;defaultStrategy = $defaultStrategy;
}
public function getDefaultStrategy($filename)
{
if (!is_string($this-&gt;defaultStrategy) &amp;&amp; is_callable($this-&gt;defaultStrategy)) {
return call_user_func($this-&gt;defaultStrategy, $filename);
}
return $this-&gt;defaultStrategy;
}
public function getName()
{
return&#039;escaper&#039;;
}
}
function twig_raw_filter($string)
{
return $string;
}
}
namespace
{
class Twig_Extension_Optimizer extends Twig_Extension
{
protected $optimizers;
public function __construct($optimizers = -1)
{
$this-&gt;optimizers = $optimizers;
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Optimizer($this-&gt;optimizers));
}
public function getName()
{
return&#039;optimizer&#039;;
}
}
}
namespace
{
interface Twig_LoaderInterface
{
public function getSource($name);
public function getCacheKey($name);
public function isFresh($name, $time);
}
}
namespace
{
class Twig_Markup implements Countable
{
protected $content;
protected $charset;
public function __construct($content, $charset)
{
$this-&gt;content = (string) $content;
$this-&gt;charset = $charset;
}
public function __toString()
{
return $this-&gt;content;
}
public function count()
{
return function_exists(&#039;mb_get_info&#039;) ? mb_strlen($this-&gt;content, $this-&gt;charset) : strlen($this-&gt;content);
}
}
}
namespace
{
interface Twig_TemplateInterface
{
const ANY_CALL =&#039;any&#039;;
const ARRAY_CALL =&#039;array&#039;;
const METHOD_CALL =&#039;method&#039;;
public function render(array $context);
public function display(array $context, array $blocks = array());
public function getEnvironment();
}
}
namespace
{
abstract class Twig_Template implements Twig_TemplateInterface
{
protected static $cache = array();
protected $parent;
protected $parents;
protected $env;
protected $blocks;
protected $traits;
public function __construct(Twig_Environment $env)
{
$this-&gt;env = $env;
$this-&gt;blocks = array();
$this-&gt;traits = array();
}
abstract public function getTemplateName();
public function getEnvironment()
{
return $this-&gt;env;
}
public function getParent(array $context)
{
if (null !== $this-&gt;parent) {
return $this-&gt;parent;
}
$parent = $this-&gt;doGetParent($context);
if (false === $parent) {
return false;
} elseif ($parent instanceof Twig_Template) {
$name = $parent-&gt;getTemplateName();
$this-&gt;parents[$name] = $parent;
$parent = $name;
} elseif (!isset($this-&gt;parents[$parent])) {
$this-&gt;parents[$parent] = $this-&gt;env-&gt;loadTemplate($parent);
}
return $this-&gt;parents[$parent];
}
protected function doGetParent(array $context)
{
return false;
}
public function isTraitable()
{
return true;
}
public function displayParentBlock($name, array $context, array $blocks = array())
{
$name = (string) $name;
if (isset($this-&gt;traits[$name])) {
$this-&gt;traits[$name][0]-&gt;displayBlock($name, $context, $blocks);
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, $blocks);
} else {
throw new Twig_Error_Runtime(sprintf(&#039;The template has no parent and no traits defining the &quot;%s&quot; block&#039;, $name), -1, $this-&gt;getTemplateName());
}
}
public function displayBlock($name, array $context, array $blocks = array())
{
$name = (string) $name;
if (isset($blocks[$name])) {
$b = $blocks;
unset($b[$name]);
call_user_func($blocks[$name], $context, $b);
} elseif (isset($this-&gt;blocks[$name])) {
call_user_func($this-&gt;blocks[$name], $context, $blocks);
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, array_merge($this-&gt;blocks, $blocks));
}
}
public function renderParentBlock($name, array $context, array $blocks = array())
{
ob_start();
$this-&gt;displayParentBlock($name, $context, $blocks);
return ob_get_clean();
}
public function renderBlock($name, array $context, array $blocks = array())
{
ob_start();
$this-&gt;displayBlock($name, $context, $blocks);
return ob_get_clean();
}
public function hasBlock($name)
{
return isset($this-&gt;blocks[(string) $name]);
}
public function getBlockNames()
{
return array_keys($this-&gt;blocks);
}
public function getBlocks()
{
return $this-&gt;blocks;
}
public function display(array $context, array $blocks = array())
{
$this-&gt;displayWithErrorHandling($this-&gt;env-&gt;mergeGlobals($context), $blocks);
}
public function render(array $context)
{
$level = ob_get_level();
ob_start();
try {
$this-&gt;display($context);
} catch (Exception $e) {
while (ob_get_level() &gt; $level) {
ob_end_clean();
}
throw $e;
}
return ob_get_clean();
}
protected function displayWithErrorHandling(array $context, array $blocks = array())
{
try {
$this-&gt;doDisplay($context, $blocks);
} catch (Twig_Error $e) {
if (!$e-&gt;getTemplateFile()) {
$e-&gt;setTemplateFile($this-&gt;getTemplateName());
}
if (false === $e-&gt;getTemplateLine()) {
$e-&gt;setTemplateLine(-1);
$e-&gt;guess();
}
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the rendering of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, null, $e);
}
}
abstract protected function doDisplay(array $context, array $blocks = array());
final protected function getContext($context, $item, $ignoreStrictCheck = false)
{
if (!array_key_exists($item, $context)) {
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Variable &quot;%s&quot; does not exist&#039;, $item), -1, $this-&gt;getTemplateName());
}
return $context[$item];
}
protected function getAttribute($object, $item, array $arguments = array(), $type = Twig_TemplateInterface::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false)
{
$item = ctype_digit((string) $item) ? (int) $item : (string) $item;
if (Twig_TemplateInterface::METHOD_CALL !== $type) {
if ((is_array($object) &amp;&amp; array_key_exists($item, $object))
|| ($object instanceof ArrayAccess &amp;&amp; isset($object[$item]))
) {
if ($isDefinedTest) {
return true;
}
return $object[$item];
}
if (Twig_TemplateInterface::ARRAY_CALL === $type) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
if (is_object($object)) {
throw new Twig_Error_Runtime(sprintf(&#039;Key &quot;%s&quot; in object (with ArrayAccess) of type &quot;%s&quot; does not exist&#039;, $item, get_class($object)), -1, $this-&gt;getTemplateName());
} elseif (is_array($object)) {
throw new Twig_Error_Runtime(sprintf(&#039;Key &quot;%s&quot; for array with keys &quot;%s&quot; does not exist&#039;, $item, implode(&#039;, &#039;, array_keys($object))), -1, $this-&gt;getTemplateName());
} else {
throw new Twig_Error_Runtime(sprintf(&#039;Impossible to access a key (&quot;%s&quot;) on a &quot;%s&quot; variable&#039;, $item, gettype($object)), -1, $this-&gt;getTemplateName());
}
}
}
if (!is_object($object)) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Item &quot;%s&quot; for &quot;%s&quot; does not exist&#039;, $item, is_array($object) ?&#039;Array&#039;: $object), -1, $this-&gt;getTemplateName());
}
$class = get_class($object);
if (Twig_TemplateInterface::METHOD_CALL !== $type) {
if (isset($object-&gt;$item) || array_key_exists($item, $object)) {
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkPropertyAllowed($object, $item);
}
return $object-&gt;$item;
}
}
if (!isset(self::$cache[$class][&#039;methods&#039;])) {
self::$cache[$class][&#039;methods&#039;] = array_change_key_case(array_flip(get_class_methods($object)));
}
$lcItem = strtolower($item);
if (isset(self::$cache[$class][&#039;methods&#039;][$lcItem])) {
$method = $item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;get&#039;.$lcItem])) {
$method =&#039;get&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;is&#039;.$lcItem])) {
$method =&#039;is&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;__call&#039;])) {
$method = $item;
} else {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Method &quot;%s&quot; for object &quot;%s&quot; does not exist&#039;, $item, get_class($object)), -1, $this-&gt;getTemplateName());
}
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkMethodAllowed($object, $method);
}
$ret = call_user_func_array(array($object, $method), $arguments);
if ($object instanceof Twig_TemplateInterface) {
return $ret ===&#039;&#039;?&#039;&#039;: new Twig_Markup($ret, $this-&gt;env-&gt;getCharset());
}
return $ret;
}
public static function clearCache()
{
self::$cache = array();
}
}
}
namespace Monolog\Formatter
{
interface FormatterInterface
{
public function format(array $record);
public function formatBatch(array $records);
}
}
namespace Monolog\Formatter
{
class NormalizerFormatter implements FormatterInterface
{
const SIMPLE_DATE =&quot;Y-m-d H:i:s&quot;;
protected $dateFormat;
public function __construct($dateFormat = null)
{
$this-&gt;dateFormat = $dateFormat ?: static::SIMPLE_DATE;
}
public function format(array $record)
{
return $this-&gt;normalize($record);
}
public function formatBatch(array $records)
{
foreach ($records as $key =&gt; $record) {
$records[$key] = $this-&gt;format($record);
}
return $records;
}
protected function normalize($data)
{
if (null === $data || is_scalar($data)) {
return $data;
}
if (is_array($data) || $data instanceof \Traversable) {
$normalized = array();
foreach ($data as $key =&gt; $value) {
$normalized[$key] = $this-&gt;normalize($value);
}
return $normalized;
}
if ($data instanceof \DateTime) {
return $data-&gt;format($this-&gt;dateFormat);
}
if (is_object($data)) {
return sprintf(&quot;[object] (%s: %s)&quot;, get_class($data), $this-&gt;toJson($data, true));
}
if (is_resource($data)) {
return&#039;[resource]&#039;;
}
return&#039;[unknown(&#039;.gettype($data).&#039;)]&#039;;
}
protected function toJson($data, $ignoreErrors = false)
{
if ($ignoreErrors) {
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return @json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
return @json_encode($data);
}
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
return json_encode($data);
}
}
}
namespace Monolog\Formatter
{
class LineFormatter extends NormalizerFormatter
{
const SIMPLE_FORMAT =&quot;[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n&quot;;
protected $format;
public function __construct($format = null, $dateFormat = null)
{
$this-&gt;format = $format ?: static::SIMPLE_FORMAT;
parent::__construct($dateFormat);
}
public function format(array $record)
{
$vars = parent::format($record);
$output = $this-&gt;format;
foreach ($vars[&#039;extra&#039;] as $var =&gt; $val) {
if (false !== strpos($output,&#039;%extra.&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%extra.&#039;.$var.&#039;%&#039;, $this-&gt;convertToString($val), $output);
unset($vars[&#039;extra&#039;][$var]);
}
}
foreach ($vars as $var =&gt; $val) {
$output = str_replace(&#039;%&#039;.$var.&#039;%&#039;, $this-&gt;convertToString($val), $output);
}
return $output;
}
public function formatBatch(array $records)
{
$message =&#039;&#039;;
foreach ($records as $record) {
$message .= $this-&gt;format($record);
}
return $message;
}
protected function normalize($data)
{
if (is_bool($data) || is_null($data)) {
return var_export($data, true);
}
if ($data instanceof \Exception) {
$previousText =&#039;&#039;;
if ($previous = $data-&gt;getPrevious()) {
do {
$previousText .=&#039;, &#039;.get_class($previous).&#039;: &#039;.$previous-&gt;getMessage().&#039; at &#039;.$previous-&gt;getFile().&#039;:&#039;.$previous-&gt;getLine();
} while ($previous = $previous-&gt;getPrevious());
}
return&#039;[object] (&#039;.get_class($data).&#039;: &#039;.$data-&gt;getMessage().&#039; at &#039;.$data-&gt;getFile().&#039;:&#039;.$data-&gt;getLine().$previousText.&#039;)&#039;;
}
return parent::normalize($data);
}
protected function convertToString($data)
{
if (null === $data || is_scalar($data)) {
return (string) $data;
}
$data = $this-&gt;normalize($data);
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return $this-&gt;toJson($data);
}
return str_replace(&#039;\\/&#039;,&#039;/&#039;, json_encode($data));
}
}
}
namespace Monolog\Handler
{
use Monolog\Formatter\FormatterInterface;
interface HandlerInterface
{
public function isHandling(array $record);
public function handle(array $record);
public function handleBatch(array $records);
public function pushProcessor($callback);
public function popProcessor();
public function setFormatter(FormatterInterface $formatter);
public function getFormatter();
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\LineFormatter;
abstract class AbstractHandler implements HandlerInterface
{
protected $level = Logger::DEBUG;
protected $bubble = false;
protected $formatter;
protected $processors = array();
public function __construct($level = Logger::DEBUG, $bubble = true)
{
$this-&gt;level = $level;
$this-&gt;bubble = $bubble;
}
public function isHandling(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;level;
}
public function handleBatch(array $records)
{
foreach ($records as $record) {
$this-&gt;handle($record);
}
}
public function close()
{
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function setFormatter(FormatterInterface $formatter)
{
$this-&gt;formatter = $formatter;
}
public function getFormatter()
{
if (!$this-&gt;formatter) {
$this-&gt;formatter = $this-&gt;getDefaultFormatter();
}
return $this-&gt;formatter;
}
public function setLevel($level)
{
$this-&gt;level = $level;
}
public function getLevel()
{
return $this-&gt;level;
}
public function setBubble($bubble)
{
$this-&gt;bubble = $bubble;
}
public function getBubble()
{
return $this-&gt;bubble;
}
public function __destruct()
{
try {
$this-&gt;close();
} catch (\Exception $e) {
}
}
protected function getDefaultFormatter()
{
return new LineFormatter();
}
}
}
namespace Monolog\Handler
{
abstract class AbstractProcessingHandler extends AbstractHandler
{
public function handle(array $record)
{
if ($record[&#039;level&#039;] &lt; $this-&gt;level) {
return false;
}
$record = $this-&gt;processRecord($record);
$record[&#039;formatted&#039;] = $this-&gt;getFormatter()-&gt;format($record);
$this-&gt;write($record);
return false === $this-&gt;bubble;
}
abstract protected function write(array $record);
protected function processRecord(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
return $record;
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class StreamHandler extends AbstractProcessingHandler
{
protected $stream;
protected $url;
public function __construct($stream, $level = Logger::DEBUG, $bubble = true)
{
parent::__construct($level, $bubble);
if (is_resource($stream)) {
$this-&gt;stream = $stream;
} else {
$this-&gt;url = $stream;
}
}
public function close()
{
if (is_resource($this-&gt;stream)) {
fclose($this-&gt;stream);
}
$this-&gt;stream = null;
}
protected function write(array $record)
{
if (null === $this-&gt;stream) {
if (!$this-&gt;url) {
throw new \LogicException(&#039;Missing stream url, the stream can not be opened. This may be caused by a premature call to close().&#039;);
}
$errorMessage = null;
set_error_handler(function ($code, $msg) use (&amp;$errorMessage) {
$errorMessage = preg_replace(&#039;{^fopen\(.*?\): }&#039;,&#039;&#039;, $msg);
});
$this-&gt;stream = fopen($this-&gt;url,&#039;a&#039;);
restore_error_handler();
if (!is_resource($this-&gt;stream)) {
$this-&gt;stream = null;
throw new \UnexpectedValueException(sprintf(&#039;The stream or file &quot;%s&quot; could not be opened: &#039;.$errorMessage, $this-&gt;url));
}
}
fwrite($this-&gt;stream, (string) $record[&#039;formatted&#039;]);
}
}
}
namespace Monolog\Handler
{
use Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy;
use Monolog\Handler\FingersCrossed\ActivationStrategyInterface;
use Monolog\Logger;
class FingersCrossedHandler extends AbstractHandler
{
protected $handler;
protected $activationStrategy;
protected $buffering = true;
protected $bufferSize;
protected $buffer = array();
protected $stopBuffering;
public function __construct($handler, $activationStrategy = null, $bufferSize = 0, $bubble = true, $stopBuffering = true)
{
if (null === $activationStrategy) {
$activationStrategy = new ErrorLevelActivationStrategy(Logger::WARNING);
}
if (!$activationStrategy instanceof ActivationStrategyInterface) {
$activationStrategy = new ErrorLevelActivationStrategy($activationStrategy);
}
$this-&gt;handler = $handler;
$this-&gt;activationStrategy = $activationStrategy;
$this-&gt;bufferSize = $bufferSize;
$this-&gt;bubble = $bubble;
$this-&gt;stopBuffering = $stopBuffering;
}
public function isHandling(array $record)
{
return true;
}
public function handle(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
if ($this-&gt;buffering) {
$this-&gt;buffer[] = $record;
if ($this-&gt;bufferSize &gt; 0 &amp;&amp; count($this-&gt;buffer) &gt; $this-&gt;bufferSize) {
array_shift($this-&gt;buffer);
}
if ($this-&gt;activationStrategy-&gt;isHandlerActivated($record)) {
if ($this-&gt;stopBuffering) {
$this-&gt;buffering = false;
}
if (!$this-&gt;handler instanceof HandlerInterface) {
if (!is_callable($this-&gt;handler)) {
throw new \RuntimeException(&quot;The given handler (&quot;.json_encode($this-&gt;handler).&quot;) is not a callable nor a Monolog\Handler\HandlerInterface object&quot;);
}
$this-&gt;handler = call_user_func($this-&gt;handler, $record, $this);
if (!$this-&gt;handler instanceof HandlerInterface) {
throw new \RuntimeException(&quot;The factory callable should return a HandlerInterface&quot;);
}
}
$this-&gt;handler-&gt;handleBatch($this-&gt;buffer);
$this-&gt;buffer = array();
}
} else {
$this-&gt;handler-&gt;handle($record);
}
return false === $this-&gt;bubble;
}
public function reset()
{
$this-&gt;buffering = true;
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class TestHandler extends AbstractProcessingHandler
{
protected $records = array();
protected $recordsByLevel = array();
public function getRecords()
{
return $this-&gt;records;
}
public function hasEmergency($record)
{
return $this-&gt;hasRecord($record, Logger::EMERGENCY);
}
public function hasAlert($record)
{
return $this-&gt;hasRecord($record, Logger::ALERT);
}
public function hasCritical($record)
{
return $this-&gt;hasRecord($record, Logger::CRITICAL);
}
public function hasError($record)
{
return $this-&gt;hasRecord($record, Logger::ERROR);
}
public function hasWarning($record)
{
return $this-&gt;hasRecord($record, Logger::WARNING);
}
public function hasNotice($record)
{
return $this-&gt;hasRecord($record, Logger::NOTICE);
}
public function hasInfo($record)
{
return $this-&gt;hasRecord($record, Logger::INFO);
}
public function hasDebug($record)
{
return $this-&gt;hasRecord($record, Logger::DEBUG);
}
public function hasEmergencyRecords()
{
return isset($this-&gt;recordsByLevel[Logger::EMERGENCY]);
}
public function hasAlertRecords()
{
return isset($this-&gt;recordsByLevel[Logger::ALERT]);
}
public function hasCriticalRecords()
{
return isset($this-&gt;recordsByLevel[Logger::CRITICAL]);
}
public function hasErrorRecords()
{
return isset($this-&gt;recordsByLevel[Logger::ERROR]);
}
public function hasWarningRecords()
{
return isset($this-&gt;recordsByLevel[Logger::WARNING]);
}
public function hasNoticeRecords()
{
return isset($this-&gt;recordsByLevel[Logger::NOTICE]);
}
public function hasInfoRecords()
{
return isset($this-&gt;recordsByLevel[Logger::INFO]);
}
public function hasDebugRecords()
{
return isset($this-&gt;recordsByLevel[Logger::DEBUG]);
}
protected function hasRecord($record, $level)
{
if (!isset($this-&gt;recordsByLevel[$level])) {
return false;
}
if (is_array($record)) {
$record = $record[&#039;message&#039;];
}
foreach ($this-&gt;recordsByLevel[$level] as $rec) {
if ($rec[&#039;message&#039;] === $record) {
return true;
}
}
return false;
}
protected function write(array $record)
{
$this-&gt;recordsByLevel[$record[&#039;level&#039;]][] = $record;
$this-&gt;records[] = $record;
}
}
}
namespace Psr\Log
{
interface LoggerInterface
{
public function emergency($message, array $context = array());
public function alert($message, array $context = array());
public function critical($message, array $context = array());
public function error($message, array $context = array());
public function warning($message, array $context = array());
public function notice($message, array $context = array());
public function info($message, array $context = array());
public function debug($message, array $context = array());
public function log($level, $message, array $context = array());
}
}
namespace Monolog
{
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\StreamHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\InvalidArgumentException;
class Logger implements LoggerInterface
{
const DEBUG = 100;
const INFO = 200;
const NOTICE = 250;
const WARNING = 300;
const ERROR = 400;
const CRITICAL = 500;
const ALERT = 550;
const EMERGENCY = 600;
protected static $levels = array(
100 =&gt;&#039;DEBUG&#039;,
200 =&gt;&#039;INFO&#039;,
250 =&gt;&#039;NOTICE&#039;,
300 =&gt;&#039;WARNING&#039;,
400 =&gt;&#039;ERROR&#039;,
500 =&gt;&#039;CRITICAL&#039;,
550 =&gt;&#039;ALERT&#039;,
600 =&gt;&#039;EMERGENCY&#039;,
);
protected static $timezone;
protected $name;
protected $handlers;
protected $processors;
public function __construct($name, array $handlers = array(), array $processors = array())
{
$this-&gt;name = $name;
$this-&gt;handlers = $handlers;
$this-&gt;processors = $processors;
}
public function getName()
{
return $this-&gt;name;
}
public function pushHandler(HandlerInterface $handler)
{
array_unshift($this-&gt;handlers, $handler);
}
public function popHandler()
{
if (!$this-&gt;handlers) {
throw new \LogicException(&#039;You tried to pop from an empty handler stack.&#039;);
}
return array_shift($this-&gt;handlers);
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function addRecord($level, $message, array $context = array())
{
if (!$this-&gt;handlers) {
$this-&gt;pushHandler(new StreamHandler(&#039;php://stderr&#039;, static::DEBUG));
}
if (!static::$timezone) {
static::$timezone = new \DateTimeZone(date_default_timezone_get() ?:&#039;UTC&#039;);
}
$record = array(&#039;message&#039;=&gt; (string) $message,&#039;context&#039;=&gt; $context,&#039;level&#039;=&gt; $level,&#039;level_name&#039;=&gt; static::getLevelName($level),&#039;channel&#039;=&gt; $this-&gt;name,&#039;datetime&#039;=&gt; \DateTime::createFromFormat(&#039;U.u&#039;, sprintf(&#039;%.6F&#039;, microtime(true)), static::$timezone)-&gt;setTimezone(static::$timezone),&#039;extra&#039;=&gt; array(),
);
$handlerKey = null;
foreach ($this-&gt;handlers as $key =&gt; $handler) {
if ($handler-&gt;isHandling($record)) {
$handlerKey = $key;
break;
}
}
if (null === $handlerKey) {
return false;
}
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
while (isset($this-&gt;handlers[$handlerKey]) &amp;&amp;
false === $this-&gt;handlers[$handlerKey]-&gt;handle($record)) {
$handlerKey++;
}
return true;
}
public function addDebug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function addInfo($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function addNotice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function addWarning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function addError($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function addCritical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function addAlert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function addEmergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public static function getLevels()
{
return array_flip(static::$levels);
}
public static function getLevelName($level)
{
if (!isset(static::$levels[$level])) {
throw new InvalidArgumentException(&#039;Level &quot;&#039;.$level.&#039;&quot; is not defined, use one of: &#039;.implode(&#039;, &#039;, array_keys(static::$levels)));
}
return static::$levels[$level];
}
public function isHandling($level)
{
$record = array(&#039;level&#039;=&gt; $level,
);
foreach ($this-&gt;handlers as $handler) {
if ($handler-&gt;isHandling($record)) {
return true;
}
}
return false;
}
public function log($level, $message, array $context = array())
{
if (is_string($level) &amp;&amp; defined(__CLASS__.&#039;::&#039;.strtoupper($level))) {
$level = constant(__CLASS__.&#039;::&#039;.strtoupper($level));
}
return $this-&gt;addRecord($level, $message, $context);
}
public function debug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function info($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function notice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function warn($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function warning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function err($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function error($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function crit($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function critical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function alert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function emerg($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public function emergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
}
}
namespace Symfony\Component\HttpKernel\Log
{
use Psr\Log\LoggerInterface as PsrLogger;
interface LoggerInterface extends PsrLogger
{
public function emerg($message, array $context = array());
public function crit($message, array $context = array());
public function err($message, array $context = array());
public function warn($message, array $context = array());
}
}
namespace Symfony\Component\HttpKernel\Log
{
interface DebugLoggerInterface
{
public function getLogs();
public function countErrors();
}
}
namespace Symfony\Bridge\Monolog
{
use Monolog\Logger as BaseLogger;
use Symfony\Component\HttpKernel\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class Logger extends BaseLogger implements LoggerInterface, DebugLoggerInterface
{
public function emerg($message, array $context = array())
{
return parent::addRecord(BaseLogger::EMERGENCY, $message, $context);
}
public function crit($message, array $context = array())
{
return parent::addRecord(BaseLogger::CRITICAL, $message, $context);
}
public function err($message, array $context = array())
{
return parent::addRecord(BaseLogger::ERROR, $message, $context);
}
public function warn($message, array $context = array())
{
return parent::addRecord(BaseLogger::WARNING, $message, $context);
}
public function getLogs()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;getLogs();
}
}
public function countErrors()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;countErrors();
}
}
private function getDebugLogger()
{
foreach ($this-&gt;handlers as $handler) {
if ($handler instanceof DebugLoggerInterface) {
return $handler;
}
}
}
}
}
namespace Symfony\Bridge\Monolog\Handler
{
use Monolog\Logger;
use Monolog\Handler\TestHandler;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class DebugHandler extends TestHandler implements DebugLoggerInterface
{
public function getLogs()
{
$records = array();
foreach ($this-&gt;records as $record) {
$records[] = array(&#039;timestamp&#039;=&gt; $record[&#039;datetime&#039;]-&gt;getTimestamp(),&#039;message&#039;=&gt; $record[&#039;message&#039;],&#039;priority&#039;=&gt; $record[&#039;level&#039;],&#039;priorityName&#039;=&gt; $record[&#039;level_name&#039;],&#039;context&#039;=&gt; $record[&#039;context&#039;],
);
}
return $records;
}
public function countErrors()
{
$cnt = 0;
$levels = array(Logger::ERROR, Logger::CRITICAL, Logger::ALERT, Logger::EMERGENCY);
foreach ($levels as $level) {
if (isset($this-&gt;recordsByLevel[$level])) {
$cnt += count($this-&gt;recordsByLevel[$level]);
}
}
return $cnt;
}
}
}
namespace Monolog\Handler\FingersCrossed
{
interface ActivationStrategyInterface
{
public function isHandlerActivated(array $record);
}
}
namespace Monolog\Handler\FingersCrossed
{
class ErrorLevelActivationStrategy implements ActivationStrategyInterface
{
private $actionLevel;
public function __construct($actionLevel)
{
$this-&gt;actionLevel = $actionLevel;
}
public function isHandlerActivated(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;actionLevel;
}
}
}
namespace Assetic
{
interface ValueSupplierInterface
{
public function getValues();
}
}
namespace Symfony\Bundle\AsseticBundle
{
use Assetic\ValueSupplierInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
class DefaultValueSupplier implements ValueSupplierInterface
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function getValues()
{
if (!$this-&gt;container-&gt;isScopeActive(&#039;request&#039;)) {
return array();
}
$request = $this-&gt;container-&gt;get(&#039;request&#039;);
return array(&#039;locale&#039;=&gt; $request-&gt;getLocale(),&#039;env&#039;=&gt; $this-&gt;container-&gt;getParameter(&#039;kernel.environment&#039;),
);
}
}}
namespace Assetic\Factory
{
use Assetic\Asset\AssetCollection;
use Assetic\Asset\AssetCollectionInterface;
use Assetic\Asset\AssetInterface;
use Assetic\Asset\AssetReference;
use Assetic\Asset\FileAsset;
use Assetic\Asset\GlobAsset;
use Assetic\Asset\HttpAsset;
use Assetic\AssetManager;
use Assetic\Factory\Worker\WorkerInterface;
use Assetic\FilterManager;
class AssetFactory
{
private $root;
private $debug;
private $output;
private $workers;
private $am;
private $fm;
public function __construct($root, $debug = false)
{
$this-&gt;root = rtrim($root,&#039;/&#039;);
$this-&gt;debug = $debug;
$this-&gt;output =&#039;assetic/*&#039;;
$this-&gt;workers = array();
}
public function setDebug($debug)
{
$this-&gt;debug = $debug;
}
public function isDebug()
{
return $this-&gt;debug;
}
public function setDefaultOutput($output)
{
$this-&gt;output = $output;
}
public function addWorker(WorkerInterface $worker)
{
$this-&gt;workers[] = $worker;
}
public function getAssetManager()
{
return $this-&gt;am;
}
public function setAssetManager(AssetManager $am)
{
$this-&gt;am = $am;
}
public function getFilterManager()
{
return $this-&gt;fm;
}
public function setFilterManager(FilterManager $fm)
{
$this-&gt;fm = $fm;
}
public function createAsset($inputs = array(), $filters = array(), array $options = array())
{
if (!is_array($inputs)) {
$inputs = array($inputs);
}
if (!is_array($filters)) {
$filters = array($filters);
}
if (!isset($options[&#039;output&#039;])) {
$options[&#039;output&#039;] = $this-&gt;output;
}
if (!isset($options[&#039;vars&#039;])) {
$options[&#039;vars&#039;] = array();
}
if (!isset($options[&#039;debug&#039;])) {
$options[&#039;debug&#039;] = $this-&gt;debug;
}
if (!isset($options[&#039;root&#039;])) {
$options[&#039;root&#039;] = array($this-&gt;root);
} else {
if (!is_array($options[&#039;root&#039;])) {
$options[&#039;root&#039;] = array($options[&#039;root&#039;]);
}
$options[&#039;root&#039;][] = $this-&gt;root;
}
if (!isset($options[&#039;name&#039;])) {
$options[&#039;name&#039;] = $this-&gt;generateAssetName($inputs, $filters, $options);
}
$asset = $this-&gt;createAssetCollection(array(), $options);
$extensions = array();
foreach ($inputs as $input) {
if (is_array($input)) {
$asset-&gt;add(call_user_func_array(array($this,&#039;createAsset&#039;), $input));
} else {
$asset-&gt;add($this-&gt;parseInput($input, $options));
$extensions[pathinfo($input, PATHINFO_EXTENSION)] = true;
}
}
foreach ($filters as $filter) {
if (&#039;?&#039;!= $filter[0]) {
$asset-&gt;ensureFilter($this-&gt;getFilter($filter));
} elseif (!$options[&#039;debug&#039;]) {
$asset-&gt;ensureFilter($this-&gt;getFilter(substr($filter, 1)));
}
}
if (!empty($options[&#039;vars&#039;])) {
$toAdd = array();
foreach ($options[&#039;vars&#039;] as $var) {
if (false !== strpos($options[&#039;output&#039;],&#039;{&#039;.$var.&#039;}&#039;)) {
continue;
}
$toAdd[] =&#039;{&#039;.$var.&#039;}&#039;;
}
if ($toAdd) {
$options[&#039;output&#039;] = str_replace(&#039;*&#039;,&#039;*.&#039;.implode(&#039;.&#039;, $toAdd), $options[&#039;output&#039;]);
}
}
if (1 == count($extensions) &amp;&amp; !pathinfo($options[&#039;output&#039;], PATHINFO_EXTENSION) &amp;&amp; $extension = key($extensions)) {
$options[&#039;output&#039;] .=&#039;.&#039;.$extension;
}
$asset-&gt;setTargetPath(str_replace(&#039;*&#039;, $options[&#039;name&#039;], $options[&#039;output&#039;]));
return $this-&gt;applyWorkers($asset);
}
public function generateAssetName($inputs, $filters, $options = array())
{
foreach (array_diff(array_keys($options), array(&#039;output&#039;,&#039;debug&#039;,&#039;root&#039;)) as $key) {
unset($options[$key]);
}
ksort($options);
return substr(sha1(serialize($inputs).serialize($filters).serialize($options)), 0, 7);
}
protected function parseInput($input, array $options = array())
{
if (&#039;@&#039;== $input[0]) {
return $this-&gt;createAssetReference(substr($input, 1));
}
if (false !== strpos($input,&#039;://&#039;) || 0 === strpos($input,&#039;//&#039;)) {
return $this-&gt;createHttpAsset($input, $options[&#039;vars&#039;]);
}
if (self::isAbsolutePath($input)) {
if ($root = self::findRootDir($input, $options[&#039;root&#039;])) {
$path = ltrim(substr($input, strlen($root)),&#039;/&#039;);
} else {
$path = null;
}
} else {
$root = $this-&gt;root;
$path = $input;
$input = $this-&gt;root.&#039;/&#039;.$path;
}
if (false !== strpos($input,&#039;*&#039;)) {
return $this-&gt;createGlobAsset($input, $root, $options[&#039;vars&#039;]);
}
return $this-&gt;createFileAsset($input, $root, $path, $options[&#039;vars&#039;]);
}
protected function createAssetCollection(array $assets = array(), array $options = array())
{
return new AssetCollection($assets, array(), null, isset($options[&#039;vars&#039;]) ? $options[&#039;vars&#039;] : array());
}
protected function createAssetReference($name)
{
if (!$this-&gt;am) {
throw new \LogicException(&#039;There is no asset manager.&#039;);
}
return new AssetReference($this-&gt;am, $name);
}
protected function createHttpAsset($sourceUrl, $vars)
{
return new HttpAsset($sourceUrl, array(), false, $vars);
}
protected function createGlobAsset($glob, $root = null, $vars)
{
return new GlobAsset($glob, array(), $root, $vars);
}
protected function createFileAsset($source, $root = null, $path = null, $vars)
{
return new FileAsset($source, array(), $root, $path, $vars);
}
protected function getFilter($name)
{
if (!$this-&gt;fm) {
throw new \LogicException(&#039;There is no filter manager.&#039;);
}
return $this-&gt;fm-&gt;get($name);
}
private function applyWorkers(AssetCollectionInterface $asset)
{
foreach ($asset as $leaf) {
foreach ($this-&gt;workers as $worker) {
$retval = $worker-&gt;process($leaf);
if ($retval instanceof AssetInterface &amp;&amp; $leaf !== $retval) {
$asset-&gt;replaceLeaf($leaf, $retval);
}
}
}
foreach ($this-&gt;workers as $worker) {
$retval = $worker-&gt;process($asset);
if ($retval instanceof AssetInterface) {
$asset = $retval;
}
}
return $asset instanceof AssetCollectionInterface ? $asset : $this-&gt;createAssetCollection(array($asset));
}
private static function isAbsolutePath($path)
{
return&#039;/&#039;== $path[0] ||&#039;\\&#039;== $path[0] || (3 &lt; strlen($path) &amp;&amp; ctype_alpha($path[0]) &amp;&amp; $path[1] ==&#039;:&#039;&amp;&amp; (&#039;\\&#039;== $path[2] ||&#039;/&#039;== $path[2]));
}
private static function findRootDir($path, array $roots)
{
foreach ($roots as $root) {
if (0 === strpos($path, $root)) {
return $root;
}
}
}
}
}
namespace Symfony\Bundle\AsseticBundle\Factory
{
use Assetic\Factory\AssetFactory as BaseAssetFactory;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;
use Symfony\Component\HttpKernel\KernelInterface;
class AssetFactory extends BaseAssetFactory
{
private $kernel;
private $container;
private $parameterBag;
public function __construct(KernelInterface $kernel, ContainerInterface $container, ParameterBagInterface $parameterBag, $baseDir, $debug = false)
{
$this-&gt;kernel = $kernel;
$this-&gt;container = $container;
$this-&gt;parameterBag = $parameterBag;
parent::__construct($baseDir, $debug);
}
protected function parseInput($input, array $options = array())
{
$input = $this-&gt;parameterBag-&gt;resolveValue($input);
if (&#039;@&#039;== $input[0] &amp;&amp; false !== strpos($input,&#039;/&#039;)) {
$bundle = substr($input, 1);
if (false !== $pos = strpos($bundle,&#039;/&#039;)) {
$bundle = substr($bundle, 0, $pos);
}
$options[&#039;root&#039;] = array($this-&gt;kernel-&gt;getBundle($bundle)-&gt;getPath());
if (false !== $pos = strpos($input,&#039;*&#039;)) {
list($before, $after) = explode(&#039;*&#039;, $input, 2);
$input = $this-&gt;kernel-&gt;locateResource($before).&#039;*&#039;.$after;
} else {
$input = $this-&gt;kernel-&gt;locateResource($input);
}
}
return parent::parseInput($input, $options);
}
protected function createAssetReference($name)
{
if (!$this-&gt;getAssetManager()) {
$this-&gt;setAssetManager($this-&gt;container-&gt;get(&#039;assetic.asset_manager&#039;));
}
return parent::createAssetReference($name);
}
protected function getFilter($name)
{
if (!$this-&gt;getFilterManager()) {
$this-&gt;setFilterManager($this-&gt;container-&gt;get(&#039;assetic.filter_manager&#039;));
}
return parent::getFilter($name);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Doctrine\Common\Annotations\Reader;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Doctrine\Common\Util\ClassUtils;
class ControllerListener
{
protected $reader;
public function __construct(Reader $reader)
{
$this-&gt;reader = $reader;
}
public function onKernelController(FilterControllerEvent $event)
{
if (!is_array($controller = $event-&gt;getController())) {
return;
}
$className = class_exists(&#039;Doctrine\Common\Util\ClassUtils&#039;) ? ClassUtils::getClass($controller[0]) : get_class($controller[0]);
$object = new \ReflectionClass($className);
$method = $object-&gt;getMethod($controller[1]);
$classConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getClassAnnotations($object));
$methodConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getMethodAnnotations($method));
$configurations = array();
foreach (array_merge(array_keys($classConfigurations), array_keys($methodConfigurations)) as $key) {
if (!array_key_exists($key, $classConfigurations)) {
$configurations[$key] = $methodConfigurations[$key];
} elseif (!array_key_exists($key, $methodConfigurations)) {
$configurations[$key] = $classConfigurations[$key];
} else {
if (is_array($classConfigurations[$key])) {
if (!is_array($methodConfigurations[$key])) {
throw new \UnexpectedValueException(&#039;Configurations should both be an array or both not be an array&#039;);
}
$configurations[$key] = array_merge($classConfigurations[$key], $methodConfigurations[$key]);
} else {
$configurations[$key] = $methodConfigurations[$key];
}
}
}
$request = $event-&gt;getRequest();
foreach ($configurations as $key =&gt; $attributes) {
$request-&gt;attributes-&gt;set($key, $attributes);
}
}
protected function getConfigurations(array $annotations)
{
$configurations = array();
foreach ($annotations as $configuration) {
if ($configuration instanceof ConfigurationInterface) {
if ($configuration-&gt;allowArray()) {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()][] = $configuration;
} else {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()] = $configuration;
}
}
}
return $configurations;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
class ParamConverterListener
{
protected $manager;
public function __construct(ParamConverterManager $manager)
{
$this-&gt;manager = $manager;
}
public function onKernelController(FilterControllerEvent $event)
{
$controller = $event-&gt;getController();
$request = $event-&gt;getRequest();
$configurations = array();
if ($configuration = $request-&gt;attributes-&gt;get(&#039;_converters&#039;)) {
foreach (is_array($configuration) ? $configuration : array($configuration) as $configuration) {
$configurations[$configuration-&gt;getName()] = $configuration;
}
}
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} else {
$r = new \ReflectionFunction($controller);
}
foreach ($r-&gt;getParameters() as $param) {
if (!$param-&gt;getClass() || $param-&gt;getClass()-&gt;isInstance($request)) {
continue;
}
$name = $param-&gt;getName();
if (!isset($configurations[$name])) {
$configuration = new ParamConverter(array());
$configuration-&gt;setName($name);
$configuration-&gt;setClass($param-&gt;getClass()-&gt;getName());
$configurations[$name] = $configuration;
} elseif (null === $configurations[$name]-&gt;getClass()) {
$configurations[$name]-&gt;setClass($param-&gt;getClass()-&gt;getName());
}
$configurations[$name]-&gt;setIsOptional($param-&gt;isOptional());
}
$this-&gt;manager-&gt;apply($request, $configurations);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Symfony\Component\HttpFoundation\Request;
interface ParamConverterInterface
{
function apply(Request $request, ConfigurationInterface $configuration);
function supports(ConfigurationInterface $configuration);
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use DateTime;
class DateTimeParamConverter implements ParamConverterInterface
{
public function apply(Request $request, ConfigurationInterface $configuration)
{
$param = $configuration-&gt;getName();
if (!$request-&gt;attributes-&gt;has($param)) {
return false;
}
$options = $configuration-&gt;getOptions();
$value = $request-&gt;attributes-&gt;get($param);
$date = isset($options[&#039;format&#039;])
? DateTime::createFromFormat($options[&#039;format&#039;], $value)
: new DateTime($value);
if (!$date) {
throw new NotFoundHttpException(&#039;Invalid date given.&#039;);
}
$request-&gt;attributes-&gt;set($param, $date);
return true;
}
public function supports(ConfigurationInterface $configuration)
{
if (null === $configuration-&gt;getClass()) {
return false;
}
return&quot;DateTime&quot;=== $configuration-&gt;getClass();
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Doctrine\Common\Persistence\ManagerRegistry;
class DoctrineParamConverter implements ParamConverterInterface
{
protected $registry;
public function __construct(ManagerRegistry $registry = null)
{
$this-&gt;registry = $registry;
}
public function apply(Request $request, ConfigurationInterface $configuration)
{
$name = $configuration-&gt;getName();
$class = $configuration-&gt;getClass();
$options = $this-&gt;getOptions($configuration);
if (null === $request-&gt;attributes-&gt;get($name, false)) {
$configuration-&gt;setIsOptional(true);
}
if (false === $object = $this-&gt;find($class, $request, $options, $name)) {
if (false === $object = $this-&gt;findOneBy($class, $request, $options)) {
if ($configuration-&gt;isOptional()) {
$object = null;
} else {
throw new \LogicException(&#039;Unable to guess how to get a Doctrine instance from the request information.&#039;);
}
}
}
if (null === $object &amp;&amp; false === $configuration-&gt;isOptional()) {
throw new NotFoundHttpException(sprintf(&#039;%s object not found.&#039;, $class));
}
$request-&gt;attributes-&gt;set($name, $object);
return true;
}
protected function find($class, Request $request, $options, $name)
{
if ($options[&#039;mapping&#039;] || $options[&#039;exclude&#039;]) {
return false;
}
$id = $this-&gt;getIdentifier($request, $options, $name);
if (false === $id || null === $id) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$method = $options[&#039;repository_method&#039;];
} else {
$method =&#039;find&#039;;
}
return $this-&gt;getManager($options[&#039;entity_manager&#039;], $class)-&gt;getRepository($class)-&gt;$method($id);
}
protected function getIdentifier(Request $request, $options, $name)
{
if (isset($options[&#039;id&#039;])) {
if (!is_array($options[&#039;id&#039;])) {
$name = $options[&#039;id&#039;];
} elseif (is_array($options[&#039;id&#039;])) {
$id = array();
foreach ($options[&#039;id&#039;] as $field) {
$id[$field] = $request-&gt;attributes-&gt;get($field);
}
return $id;
}
}
if ($request-&gt;attributes-&gt;has($name)) {
return $request-&gt;attributes-&gt;get($name);
}
if ($request-&gt;attributes-&gt;has(&#039;id&#039;)) {
return $request-&gt;attributes-&gt;get(&#039;id&#039;);
}
return false;
}
protected function findOneBy($class, Request $request, $options)
{
if (!$options[&#039;mapping&#039;]) {
$keys = $request-&gt;attributes-&gt;keys();
$options[&#039;mapping&#039;] = $keys ? array_combine($keys, $keys) : array();
}
foreach ($options[&#039;exclude&#039;] as $exclude) {
unset($options[&#039;mapping&#039;][$exclude]);
}
if (!$options[&#039;mapping&#039;]) {
return false;
}
$criteria = array();
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $class);
$metadata = $em-&gt;getClassMetadata($class);
foreach ($options[&#039;mapping&#039;] as $attribute =&gt; $field) {
if ($metadata-&gt;hasField($field) || ($metadata-&gt;hasAssociation($field) &amp;&amp; $metadata-&gt;isSingleValuedAssociation($field))) {
$criteria[$field] = $request-&gt;attributes-&gt;get($attribute);
}
}
if (!$criteria) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$method = $options[&#039;repository_method&#039;];
} else {
$method =&#039;findOneBy&#039;;
}
return $em-&gt;getRepository($class)-&gt;$method($criteria);
}
public function supports(ConfigurationInterface $configuration)
{
if (!$configuration instanceof ParamConverter) {
return false;
}
if (null === $this-&gt;registry || !count($this-&gt;registry-&gt;getManagers())) {
return false;
}
if (null === $configuration-&gt;getClass()) {
return false;
}
$options = $this-&gt;getOptions($configuration);
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $configuration-&gt;getClass());
if (null === $em) {
return false;
}
return ! $em-&gt;getMetadataFactory()-&gt;isTransient($configuration-&gt;getClass());
}
protected function getOptions(ConfigurationInterface $configuration)
{
return array_replace(array(&#039;entity_manager&#039;=&gt; null,&#039;exclude&#039;=&gt; array(),&#039;mapping&#039;=&gt; array(),
), $configuration-&gt;getOptions());
}
private function getManager($name, $class)
{
if (null === $name) {
return $this-&gt;registry-&gt;getManagerForClass($class);
}
return $this-&gt;registry-&gt;getManager($name);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Symfony\Component\HttpFoundation\Request;
class ParamConverterManager
{
protected $converters = array();
protected $namedConverters = array();
public function apply(Request $request, $configurations)
{
if (is_object($configurations)) {
$configurations = array($configurations);
}
foreach ($configurations as $configuration) {
$this-&gt;applyConverter($request, $configuration);
}
}
protected function applyConverter(Request $request, $configuration)
{
$value = $request-&gt;attributes-&gt;get($configuration-&gt;getName());
$className = $configuration-&gt;getClass();
if (is_object($value) &amp;&amp; $value instanceof $className) {
return;
}
if ($converterName = $configuration-&gt;getConverter()) {
if (!isset($this-&gt;namedConverters[$converterName])) {
throw new \RuntimeException(sprintf(&quot;No converter named &#039;%s&#039; found for conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter = $this-&gt;namedConverters[$converterName];
if (!$converter-&gt;supports($configuration)) {
throw new \RuntimeException(sprintf(&quot;Converter &#039;%s&#039; does not support conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter-&gt;apply($request, $configuration);
return;
}
foreach ($this-&gt;all() as $converter) {
if ($converter-&gt;supports($configuration)) {
if ($converter-&gt;apply($request, $configuration)) {
return;
}
}
}
}
public function add(ParamConverterInterface $converter, $priority = 0, $name = null)
{
if ($priority !== null) {
if (!isset($this-&gt;converters[$priority])) {
$this-&gt;converters[$priority] = array();
}
$this-&gt;converters[$priority][] = $converter;
}
if (null !== $name) {
$this-&gt;namedConverters[$name] = $converter;
}
}
public function all()
{
krsort($this-&gt;converters);
$converters = array();
foreach ($this-&gt;converters as $all) {
$converters = array_merge($converters, $all);
}
return $converters;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent;
use Symfony\Component\HttpFoundation\StreamedResponse;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;
class TemplateListener
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function onKernelController(FilterControllerEvent $event)
{
if (!is_array($controller = $event-&gt;getController())) {
return;
}
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_template&#039;)) {
return;
}
if (!$configuration-&gt;getTemplate()) {
$guesser = $this-&gt;container-&gt;get(&#039;sensio_framework_extra.view.guesser&#039;);
$configuration-&gt;setTemplate($guesser-&gt;guessTemplateName($controller, $request, $configuration-&gt;getEngine()));
}
$request-&gt;attributes-&gt;set(&#039;_template&#039;, $configuration-&gt;getTemplate());
$request-&gt;attributes-&gt;set(&#039;_template_vars&#039;, $configuration-&gt;getVars());
$request-&gt;attributes-&gt;set(&#039;_template_streamable&#039;, $configuration-&gt;isStreamable());
if (!$configuration-&gt;getVars()) {
$r = new \ReflectionObject($controller[0]);
$vars = array();
foreach ($r-&gt;getMethod($controller[1])-&gt;getParameters() as $param) {
$vars[] = $param-&gt;getName();
}
$request-&gt;attributes-&gt;set(&#039;_template_default_vars&#039;, $vars);
}
}
public function onKernelView(GetResponseForControllerResultEvent $event)
{
$request = $event-&gt;getRequest();
$parameters = $event-&gt;getControllerResult();
$templating = $this-&gt;container-&gt;get(&#039;templating&#039;);
if (null === $parameters) {
if (!$vars = $request-&gt;attributes-&gt;get(&#039;_template_vars&#039;)) {
if (!$vars = $request-&gt;attributes-&gt;get(&#039;_template_default_vars&#039;)) {
return;
}
}
$parameters = array();
foreach ($vars as $var) {
$parameters[$var] = $request-&gt;attributes-&gt;get($var);
}
}
if (!is_array($parameters)) {
return $parameters;
}
if (!$template = $request-&gt;attributes-&gt;get(&#039;_template&#039;)) {
return $parameters;
}
if (!$request-&gt;attributes-&gt;get(&#039;_template_streamable&#039;)) {
$event-&gt;setResponse($templating-&gt;renderResponse($template, $parameters));
} else {
$callback = function () use ($templating, $template, $parameters) {
return $templating-&gt;stream($template, $parameters);
};
$event-&gt;setResponse(new StreamedResponse($callback));
}
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpFoundation\Response;
class CacheListener
{
public function onKernelResponse(FilterResponseEvent $event)
{
if (!$configuration = $event-&gt;getRequest()-&gt;attributes-&gt;get(&#039;_cache&#039;)) {
return;
}
$response = $event-&gt;getResponse();
if (!$response-&gt;isSuccessful()) {
return;
}
if (null !== $configuration-&gt;getSMaxAge()) {
$response-&gt;setSharedMaxAge($configuration-&gt;getSMaxAge());
}
if (null !== $configuration-&gt;getMaxAge()) {
$response-&gt;setMaxAge($configuration-&gt;getMaxAge());
}
if (null !== $configuration-&gt;getExpires()) {
$date = \DateTime::createFromFormat(&#039;U&#039;, strtotime($configuration-&gt;getExpires()), new \DateTimeZone(&#039;UTC&#039;));
$response-&gt;setExpires($date);
}
if (null !== $configuration-&gt;getVary()) {
$response-&gt;setVary($configuration-&gt;getVary());
}
if ($configuration-&gt;isPublic()) {
$response-&gt;setPublic();
}
$event-&gt;setResponse($response);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
interface ConfigurationInterface
{
function getAliasName();
function allowArray();
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
abstract class ConfigurationAnnotation implements ConfigurationInterface
{
public function __construct(array $values)
{
foreach ($values as $k =&gt; $v) {
if (!method_exists($this, $name =&#039;set&#039;.$k)) {
throw new \RuntimeException(sprintf(&#039;Unknown key &quot;%s&quot; for annotation &quot;@%s&quot;.&#039;, $k, get_class($this)));
}
$this-&gt;$name($v);
}
}
}
}
namespace JMS\DiExtraBundle\HttpKernel
{
use Metadata\ClassHierarchyMetadata;
use JMS\DiExtraBundle\Metadata\ClassMetadata;
use CG\Core\DefaultNamingStrategy;
use CG\Proxy\Enhancer;
use JMS\AopBundle\DependencyInjection\Compiler\PointcutMatchingPass;
use JMS\DiExtraBundle\Generator\DefinitionInjectorGenerator;
use JMS\DiExtraBundle\Generator\LookupMethodClassGenerator;
use JMS\DiExtraBundle\DependencyInjection\Dumper\PhpDumper;
use Metadata\MetadataFactory;
use Symfony\Component\DependencyInjection\Compiler\InlineServiceDefinitionsPass;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
use Symfony\Component\DependencyInjection\Compiler\ResolveDefinitionTemplatesPass;
use Symfony\Component\DependencyInjection\Parameter;
use Symfony\Component\DependencyInjection\Reference;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\Config\Resource\FileResource;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\Config\ConfigCache;
use Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver as BaseControllerResolver;
class ControllerResolver extends BaseControllerResolver
{
protected function createController($controller)
{
if (false === $pos = strpos($controller,&#039;::&#039;)) {
$count = substr_count($controller,&#039;:&#039;);
if (2 == $count) {
$controller = $this-&gt;parser-&gt;parse($controller);
$pos = strpos($controller,&#039;::&#039;);
} elseif (1 == $count) {
list($service, $method) = explode(&#039;:&#039;, $controller);
return array($this-&gt;container-&gt;get($service), $method);
} else {
throw new \LogicException(sprintf(&#039;Unable to parse the controller name &quot;%s&quot;.&#039;, $controller));
}
}
$class = substr($controller, 0, $pos);
$method = substr($controller, $pos+2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
$injector = $this-&gt;createInjector($class);
$controller = call_user_func($injector, $this-&gt;container);
if ($controller instanceof ContainerAwareInterface) {
$controller-&gt;setContainer($this-&gt;container);
}
return array($controller, $method);
}
public function createInjector($class)
{
$filename = $this-&gt;container-&gt;getParameter(&#039;jms_di_extra.cache_dir&#039;).&#039;/controller_injectors/&#039;.str_replace(&#039;\\&#039;,&#039;&#039;, $class).&#039;.php&#039;;
$cache = new ConfigCache($filename, $this-&gt;container-&gt;getParameter(&#039;kernel.debug&#039;));
if (!$cache-&gt;isFresh()) {
$metadata = $this-&gt;container-&gt;get(&#039;jms_di_extra.metadata.metadata_factory&#039;)-&gt;getMetadataForClass($class);
if (null === $metadata) {
$metadata = new ClassHierarchyMetadata();
$metadata-&gt;addClassMetadata(new ClassMetadata($class));
}
if (null !== $metadata-&gt;getOutsideClassMetadata()-&gt;id
&amp;&amp; 0 !== strpos($metadata-&gt;getOutsideClassMetadata()-&gt;id,&#039;_jms_di_extra.unnamed.service&#039;)) {
return;
}
$this-&gt;prepareContainer($cache, $filename, $metadata, $class);
}
if ( ! class_exists($class.&#039;__JMSInjector&#039;, false)) {
require $filename;
}
return array($class.&#039;__JMSInjector&#039;,&#039;inject&#039;);
}
private function prepareContainer($cache, $containerFilename, $metadata, $className)
{
$container = new ContainerBuilder();
$container-&gt;setParameter(&#039;jms_aop.cache_dir&#039;, $this-&gt;container-&gt;getParameter(&#039;jms_di_extra.cache_dir&#039;));
$def = $container
-&gt;register(&#039;jms_aop.interceptor_loader&#039;,&#039;JMS\AopBundle\Aop\InterceptorLoader&#039;)
-&gt;addArgument(new Reference(&#039;service_container&#039;))
-&gt;setPublic(false)
;
$ref = $metadata-&gt;getOutsideClassMetadata()-&gt;reflection;
while ($ref &amp;&amp; false !== $filename = $ref-&gt;getFilename()) {
$container-&gt;addResource(new FileResource($filename));
$ref = $ref-&gt;getParentClass();
}
$definitions = $this-&gt;container-&gt;get(&#039;jms_di_extra.metadata.converter&#039;)-&gt;convert($metadata);
$serviceIds = $parameters = array();
$controllerDef = array_pop($definitions);
$container-&gt;setDefinition(&#039;controller&#039;, $controllerDef);
foreach ($definitions as $id =&gt; $def) {
$container-&gt;setDefinition($id, $def);
}
$this-&gt;generateLookupMethods($controllerDef, $metadata);
$config = $container-&gt;getCompilerPassConfig();
$config-&gt;setOptimizationPasses(array());
$config-&gt;setRemovingPasses(array());
$config-&gt;addPass(new ResolveDefinitionTemplatesPass());
$config-&gt;addPass(new PointcutMatchingPass($this-&gt;container-&gt;get(&#039;jms_aop.pointcut_container&#039;)-&gt;getPointcuts()));
$config-&gt;addPass(new InlineServiceDefinitionsPass());
$container-&gt;compile();
if (!file_exists($dir = dirname($containerFilename))) {
if (false === @mkdir($dir, 0777, true)) {
throw new \RuntimeException(sprintf(&#039;Could not create directory &quot;%s&quot;.&#039;, $dir));
}
}
static $generator;
if (null === $generator) {
$generator = new DefinitionInjectorGenerator();
}
$cache-&gt;write($generator-&gt;generate($container-&gt;getDefinition(&#039;controller&#039;), $className), $container-&gt;getResources());
}
private function generateLookupMethods($def, $metadata)
{
$found = false;
foreach ($metadata-&gt;classMetadata as $cMetadata) {
if (!empty($cMetadata-&gt;lookupMethods)) {
$found = true;
break;
}
}
if (!$found) {
return;
}
$generator = new LookupMethodClassGenerator($metadata);
$outerClass = $metadata-&gt;getOutsideClassMetadata()-&gt;reflection;
if ($file = $def-&gt;getFile()) {
$generator-&gt;setRequiredFile($file);
}
$enhancer = new Enhancer(
$outerClass,
array(),
array(
$generator,
)
);
$filename = $this-&gt;container-&gt;getParameter(&#039;jms_di_extra.cache_dir&#039;).&#039;/lookup_method_classes/&#039;.str_replace(&#039;\\&#039;,&#039;-&#039;, $outerClass-&gt;name).&#039;.php&#039;;
$enhancer-&gt;writeClass($filename);
$def-&gt;setFile($filename);
$def-&gt;setClass($enhancer-&gt;getClassName($outerClass));
$def-&gt;addMethodCall(&#039;__jmsDiExtra_setContainer&#039;, array(new Reference(&#039;service_container&#039;)));
}
}
}
namespace Sonata\SeoBundle\Seo
{
interface SeoPageInterface
{
public function setTitle($title);
public function addTitle($title);
public function getTitle();
public function addMeta($type, $name, $value, array $extras = array());
public function getMetas();
public function setMetas(array $metas);
public function setHtmlAttributes(array $attributes);
public function addHtmlAttributes($name, $value);
public function getHtmlAttributes();
public function setLinkCanonical($link);
public function getLinkCanonical();
public function setSeparator($separator);
}
}
namespace Sonata\SeoBundle\Seo
{
class SeoPage implements SeoPageInterface
{
protected $title;
protected $metas;
protected $htmlAttributes;
protected $linkCanonical;
protected $separator;
protected $headAttributes;
public function __construct($title =&#039;&#039;)
{
$this-&gt;title = $title;
$this-&gt;metas = array(&#039;http-equiv&#039;=&gt; array(),&#039;name&#039;=&gt; array(),&#039;schema&#039;=&gt; array(),&#039;charset&#039;=&gt; array(),&#039;property&#039;=&gt; array(),
);
$this-&gt;headAttributes = array();
$this-&gt;linkCanonical =&#039;&#039;;
$this-&gt;separator =&#039; &#039;;
}
public function setTitle($title)
{
$this-&gt;title = $title;
return $this;
}
public function addTitle($title)
{
$this-&gt;title = $title . $this-&gt;separator . $this-&gt;title;
return $this;
}
public function getTitle()
{
return $this-&gt;title;
}
public function getMetas()
{
return $this-&gt;metas;
}
public function addMeta($type, $name, $content, array $extras = array())
{
if (!isset($this-&gt;metas[$type])) {
$this-&gt;metas[$type] = array();
}
$this-&gt;metas[$type][$name] = array($content, $extras);
return $this;
}
public function setMetas(array $metadatas)
{
$this-&gt;metas = array();
foreach ($metadatas as $type =&gt; $metas) {
if (!is_array($metas)) {
throw new \RuntimeException(&#039;$metas must be an array&#039;);
}
foreach ($metas as $name =&gt; $meta) {
list($content, $extras) = $this-&gt;normalize($meta);
$this-&gt;addMeta($type, $name, $content, $extras);
}
}
return $this;
}
private function normalize($meta)
{
if (is_string($meta)) {
return array($meta, array());
}
return $meta;
}
public function setHtmlAttributes(array $attributes)
{
$this-&gt;htmlAttributes = $attributes;
return $this;
}
public function addHtmlAttributes($name, $value)
{
$this-&gt;htmlAttributes[$name] = $value;
return $this;
}
public function getHtmlAttributes()
{
return $this-&gt;htmlAttributes;
}
public function setLinkCanonical($link)
{
$this-&gt;linkCanonical = $link;
return $this;
}
public function getLinkCanonical()
{
return $this-&gt;linkCanonical;
}
public function setSeparator($separator)
{
$this-&gt;separator = $separator;
}
}
}
namespace Exporter\Source
{
interface SourceIteratorInterface extends \Iterator
{
}
}
namespace Sonata\SeoBundle\Sitemap
{
use Exporter\Source\SourceIteratorInterface;
use Exporter\Source\ChainSourceIterator;
class SourceManager implements SourceIteratorInterface
{
protected $sources;
public function __construct()
{
$this-&gt;sources = new \ArrayIterator();
}
public function addSource($group, SourceIteratorInterface $source, array $types = array())
{
if (!isset($this-&gt;sources[$group])) {
$this-&gt;sources[$group] = new \stdClass();
$this-&gt;sources[$group]-&gt;sources = new ChainSourceIterator();
$this-&gt;sources[$group]-&gt;types = array();
}
$this-&gt;sources[$group]-&gt;sources-&gt;addSource($source);
if ($types) {
$this-&gt;sources[$group]-&gt;types += array_diff($types, $this-&gt;sources[$group]-&gt;types);
}
}
public function current()
{
return $this-&gt;sources-&gt;current();
}
public function next()
{
$this-&gt;sources-&gt;next();
}
public function key()
{
return $this-&gt;sources-&gt;key();
}
public function valid()
{
return $this-&gt;sources-&gt;valid();
}
public function rewind()
{
$this-&gt;sources-&gt;rewind();
}
}
}
namespace Sonata\SeoBundle\Twig\Extension
{
use Sonata\SeoBundle\Seo\SeoPageInterface;
class SeoExtension extends \Twig_Extension
{
protected $page;
protected $encoding;
public function __construct(SeoPageInterface $page, $encoding)
{
$this-&gt;page = $page;
$this-&gt;encoding = $encoding;
}
public function getFunctions()
{
return array(&#039;sonata_seo_title&#039;=&gt; new \Twig_Function_Method($this,&#039;renderTitle&#039;),&#039;sonata_seo_metadatas&#039;=&gt; new \Twig_Function_Method($this,&#039;renderMetadatas&#039;),&#039;sonata_seo_html_attributes&#039;=&gt; new \Twig_Function_Method($this,&#039;renderHtmlAttributes&#039;),&#039;sonata_seo_link_canonical&#039;=&gt; new \Twig_Function_Method($this,&#039;renderLinkCanonical&#039;),
);
}
public function getName()
{
return&#039;sonata_seo&#039;;
}
public function renderTitle()
{
echo sprintf(&quot;&lt;title&gt;%s&lt;/title&gt;&quot;, strip_tags($this-&gt;page-&gt;getTitle()));
}
public function renderMetadatas()
{
foreach ($this-&gt;page-&gt;getMetas() as $type =&gt; $metas) {
foreach ((array) $metas as $name =&gt; $meta) {
list($content, $extras) = $meta;
echo sprintf(&quot;&lt;meta %s=\&quot;%s\&quot; content=\&quot;%s\&quot; /&gt;\n&quot;,
$type,
$this-&gt;normalize($name),
$this-&gt;normalize($content)
);
}
}
}
public function renderHtmlAttributes()
{
foreach ($this-&gt;page-&gt;getHtmlAttributes() as $name =&gt; $value) {
echo sprintf(&#039;%s=&quot;%s&quot; &#039;, $name, $value);
}
}
public function renderLinkCanonical()
{
if ($this-&gt;page-&gt;getLinkCanonical()) {
echo sprintf(&quot;&lt;link rel=\&quot;canonical\&quot; href=\&quot;%s\&quot;/&gt;\n&quot;, $this-&gt;page-&gt;getLinkCanonical());
}
}
private function normalize($string)
{
return htmlentities(strip_tags($string), ENT_COMPAT, $this-&gt;encoding);
}
}
}') in /home/gonzalo/trackme/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 122</li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::load(<em>array</em>('Symfony\Bundle\FrameworkBundle\EventListener\SessionListener', 'Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage', 'Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy', 'Symfony\Component\HttpFoundation\Session\Session', 'Symfony\Bundle\FrameworkBundle\Templating\GlobalVariables', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateReference', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateNameParser', 'Symfony\Bundle\FrameworkBundle\Templating\Loader\TemplateLocator', 'Symfony\Component\Routing\Generator\UrlGenerator', 'Symfony\Component\Routing\RequestContext', 'Symfony\Component\Routing\Router', 'Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher', 'Symfony\Bundle\FrameworkBundle\Routing\Router', 'Symfony\Component\HttpFoundation\ParameterBag', 'Symfony\Component\HttpFoundation\HeaderBag', 'Symfony\Component\HttpFoundation\FileBag', 'Symfony\Component\HttpFoundation\ServerBag', 'Symfony\Component\HttpFoundation\Request', 'Symfony\Component\HttpFoundation\Response', 'Symfony\Component\HttpFoundation\ResponseHeaderBag', 'Symfony\Component\Config\FileLocator', 'Symfony\Component\EventDispatcher\Event', 'Symfony\Component\EventDispatcher\ContainerAwareEventDispatcher', 'Symfony\Component\HttpKernel\EventListener\ResponseListener', 'Symfony\Component\HttpKernel\EventListener\RouterListener', 'Symfony\Component\HttpKernel\Controller\ControllerResolver', 'Symfony\Component\HttpKernel\Event\KernelEvent', 'Symfony\Component\HttpKernel\Event\FilterControllerEvent', 'Symfony\Component\HttpKernel\Event\FilterResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent', 'Symfony\Component\HttpKernel\KernelEvents', 'Symfony\Component\HttpKernel\Config\FileLocator', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver', 'Symfony\Component\Security\Http\AccessMap', 'Symfony\Component\Security\Http\Firewall', 'Symfony\Component\Security\Core\SecurityContext', 'Symfony\Component\Security\Core\User\UserProviderInterface', 'Symfony\Component\Security\Core\Authentication\AuthenticationProviderManager', 'Symfony\Component\Security\Core\Authorization\AccessDecisionManager', 'Symfony\Component\Security\Core\Authorization\Voter\VoterInterface', 'Symfony\Bundle\SecurityBundle\Security\FirewallMap', 'Symfony\Bundle\SecurityBundle\Security\FirewallContext', 'Symfony\Component\HttpFoundation\RequestMatcher', 'Twig_Environment', 'Twig_Extension', 'Twig_Extension_Core', 'Twig_Extension_Escaper', 'Twig_Extension_Optimizer', 'Twig_LoaderInterface', 'Twig_Markup', 'Twig_Template', 'Monolog\Formatter\FormatterInterface', 'Monolog\Formatter\LineFormatter', 'Monolog\Handler\HandlerInterface', 'Monolog\Handler\AbstractHandler', 'Monolog\Handler\AbstractProcessingHandler', 'Monolog\Handler\StreamHandler', 'Monolog\Handler\FingersCrossedHandler', 'Monolog\Handler\TestHandler', 'Monolog\Logger', 'Symfony\Bridge\Monolog\Logger', 'Symfony\Bridge\Monolog\Handler\DebugHandler', 'Monolog\Handler\FingersCrossed\ActivationStrategyInterface', 'Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy', 'Symfony\Bundle\AsseticBundle\DefaultValueSupplier', 'Symfony\Bundle\AsseticBundle\Factory\AssetFactory', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ControllerListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ParamConverterListener', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DateTimeParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DoctrineParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterInterface', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\TemplateListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\CacheListener', 'Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationAnnotation', 'JMS\DiExtraBundle\HttpKernel\ControllerResolver', 'Sonata\SeoBundle\Seo\SeoPage', 'Sonata\SeoBundle\Seo\SeoPageInterface', 'Sonata\SeoBundle\Sitemap\SourceManager', 'Sonata\SeoBundle\Twig\Extension\SeoExtension'), '/home/gonzalo/trackme/app/cache/dev', 'classes', <em>true</em>, <em>false</em>, '.php') in /home/gonzalo/trackme/app/bootstrap.php.cache line 517</li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->loadClassCache() in /home/gonzalo/trackme/web/app_dev.php line 23</li>
    </ol>
</div>

            </div>
    </body>
</html>